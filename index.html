<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cloud 9 Video Player - The Forecast is Fun</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Cinzel:wght@700&family=Impact&family=Trajan+Pro:wght@400&display=swap"
    rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/twemoji@latest/dist/twemoji.min.js" crossorigin="anonymous"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(-45deg, #1a1a1a, #2a2a2a, #3a3a3a, #2a2a2a, #1a1a1a);
      background-size: 600% 600%;
      animation: gradientBG 30s ease infinite;
      color: #e2e8f0;
      margin: 0;
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }

    @keyframes gradientBG {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    @keyframes strobe {

      0%,
      100% {
        filter: brightness(1);
      }

      50% {
        filter: brightness(2.5);
      }
    }

    @keyframes float {
      0%, 100% { transform: translate(-50%, 0px); }
      50% { transform: translate(-50%, -8px); }
    }

    /* Twemoji Image Styling */
    img.emoji {
      height: 1em;
      width: 1em;
      margin: 0 .05em 0 .1em;
      vertical-align: -0.1em;
      display: inline-block;
    }

    .panel-toggle-button img.emoji {
      height: 1.75rem;
      width: 1.75rem;
    }

    @media (pointer: coarse) {
      .panel-toggle-button img.emoji {
        height: 2.25rem;
        width: 2.25rem;
      }
    }

    .video-full-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 10;
      background-color: #000;
    }

    .video-full-screen video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: filter 0.2s, transform 0.2s;
    }

    .video-strobe {
      animation: strobe 0.2s infinite;
    }

    .video-bw {
      filter: grayscale(1);
    }

    .video-sepia {
      filter: sepia(1);
    }

    .video-invert {
      filter: invert(1);
    }

    .video-reversed {
      transform: scaleX(-1);
    }

    /* Panel Toggle Bars */
    .panel-toggle-bar {
      position: fixed;
      top: 1rem;
      z-index: 205;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 8px;
    }

    .right-bar {
      right: 0;
      transition: right 0.35s cubic-bezier(0.25, 1, 0.5, 1);
    }

    .left-bar {
      left: 0;
      transition: left 0.35s cubic-bezier(0.25, 1, 0.5, 1);
    }

    .panel-toggle-button {
      background-color: rgba(50, 50, 50, 0.7);
      color: white;
      width: 48px;
      height: 48px;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.2s;
      font-size: 1.75rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border: none;
    }

    button {
      touch-action: manipulation;
    }

    .panel-toggle-button:hover:not(.active) {
      transform: scale(1.1);
    }

    @media (pointer: coarse) {
      .panel-toggle-button {
        width: 64px;
        height: 64px;
        font-size: 2.25rem;
      }

      button,
      input,
      select {
        min-height: 52px;
        font-size: 1.1rem;
      }
    }

    /* Panel System */
    .panel {
      position: fixed;
      top: 0;
      height: 100vh;
      width: 300px;
      background-color: rgba(20, 20, 20, 0.85);
      z-index: 200;
      transition: transform 0.35s cubic-bezier(0.25, 1, 0.5, 1);
      padding: 1.5rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .right-panel {
      right: 0;
      transform: translateX(100%);
    }

    .left-panel {
      left: 0;
      transform: translateX(-100%);
    }

    .panel.active {
      transform: translateX(0);
    }

    body.right-panel-active .right-bar {
      right: 300px;
    }

    body.left-panel-active .left-bar {
      left: 300px;
    }

    @media (max-width: 1024px) {
      .panel {
        width: min(90vw, 360px);
      }

      body.right-panel-active .right-bar {
        right: min(90vw, 360px);
      }

      body.left-panel-active .left-bar {
        left: min(90vw, 360px);
      }

      #media-controls-container {
        padding-bottom: env(safe-area-inset-bottom, 16px);
      }
    }

    .panel-header h2 {
      font-size: 1.25rem;
      margin: 0 0 1rem 0;
      font-weight: 600;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 0.5rem;
      transition: color 0.3s;
    }

    /* Rainbow Highlighting */
    .highlight-red,
    .panel-toggle-button[data-color="red"]:hover:not(.active) {
      background-color: #e74c3c !important;
    }

    .title-red {
      color: #e74c3c !important;
    }

    .highlight-orange,
    .panel-toggle-button[data-color="orange"]:hover:not(.active) {
      background-color: #e67e22 !important;
    }

    .title-orange {
      color: #e67e22 !important;
    }

    .highlight-yellow,
    .panel-toggle-button[data-color="yellow"]:hover:not(.active) {
      background-color: #f1c40f !important;
    }

    .title-yellow {
      color: #f1c40f !important;
    }

    .highlight-green,
    .panel-toggle-button[data-color="green"]:hover:not(.active) {
      background-color: #2ecc71 !important;
    }

    .title-green {
      color: #2ecc71 !important;
    }

    .highlight-blue,
    .panel-toggle-button[data-color="blue"]:hover:not(.active) {
      background-color: #3498db !important;
    }

    .title-blue {
      color: #3498db !important;
    }

    .highlight-indigo,
    .panel-toggle-button[data-color="indigo"]:hover:not(.active) {
      background-color: #8e44ad !important;
    }

    .title-indigo {
      color: #8e44ad !important;
    }

    .highlight-violet,
    .panel-toggle-button[data-color="violet"]:hover:not(.active) {
      background-color: #9b59b6 !important;
    }

    .title-violet {
      color: #9b59b6 !important;
    }

    /* Overlays */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      color: white;
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s ease-in-out, background-color 0.5s ease-in-out;
      z-index: 100;
      pointer-events: none;
      padding-top: env(safe-area-inset-top, 0);
      padding-right: env(safe-area-inset-right, 0);
      padding-bottom: env(safe-area-inset-bottom, 0);
      padding-left: env(safe-area-inset-left, 0);
    }

    .overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .countdown-overlay {
      font-size: 10rem;
    }

    .completion-overlay {
      font-size: 5rem;
      background-color: rgba(0, 0, 0, 0.7);
      pointer-events: all;
    }

    /* Guessing Game Tally Overlay */
    #on-screen-tally-container {
      position: fixed;
      inset: 0;
      display: none;
      justify-content: center;
      align-items: center;
      gap: clamp(1.5rem, 5vw, 3.5rem);
      padding: clamp(1.5rem, 6vw, 5rem);
      padding-top: max(clamp(1.5rem, 6vw, 5rem), env(safe-area-inset-top, 0));
      padding-right: max(clamp(1.5rem, 6vw, 5rem), env(safe-area-inset-right, 0));
      padding-bottom: max(clamp(1.5rem, 6vw, 5rem), env(safe-area-inset-bottom, 0));
      padding-left: max(clamp(1.5rem, 6vw, 5rem), env(safe-area-inset-left, 0));
      background: rgba(0, 0, 0, 0.55);
      backdrop-filter: blur(6px);
      z-index: 155;
      transition: opacity 0.25s ease;
      opacity: 0;
      pointer-events: none;
    }

    #on-screen-tally-container.visible {
      display: flex;
      opacity: 1;
      pointer-events: all;
    }

    .on-screen-tally-emoji {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: clamp(160px, 28vw, 260px);
      height: clamp(160px, 28vw, 260px);
      border-radius: 28px;
      background: rgba(18, 18, 18, 0.78);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
      transition: transform 0.15s ease, background 0.2s ease;
    }

    .on-screen-tally-emoji:active {
      transform: scale(0.95);
      background: rgba(40, 40, 40, 0.88);
    }

    .on-screen-tally-icon {
      font-size: clamp(4rem, 14vw, 8.5rem);
      line-height: 1;
    }

    .on-screen-tally-count {
      margin-top: clamp(0.5rem, 2vw, 1.5rem);
      font-size: clamp(2.5rem, 8vw, 4.25rem);
      font-weight: 700;
      color: #fbbf24;
      text-shadow: 0 4px 18px rgba(0, 0, 0, 0.6);
    }

    /* Breathing Overlay Specifics */
    #breathingOverlay .overlay-timer {
      font-size: 12rem;
    }

    #breathingOverlay .overlay-text {
      font-size: 4rem;
      text-transform: uppercase;
    }

    .overlay-inhale {
      background-color: rgba(52, 152, 219, 0.7);
    }

    .overlay-hold {
      background-color: rgba(127, 140, 141, 0.7);
    }

    .overlay-exhale {
      background-color: rgba(230, 126, 34, 0.7);
    }


    /* Media Controls */
    #media-controls-container {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      z-index: 104;
    }

    .media-controls-overlay {
      background-color: rgba(0, 0, 0, 0.6);
      padding: 1rem;
      transition: transform 0.3s ease-in-out;
      transform: translateY(0);
    }

    .media-controls-overlay.hidden {
      transform: translateY(100%);
    }

    .media-controls-content {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .media-controls-buttons {
      display: flex;
      justify-content: center;
      gap: 1rem;
    }

    .media-controls-buttons button {
      background-color: #4a4a4a;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      border: none;
    }

    .progress-volume-row {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .time-display {
      font-size: 0.9rem;
      min-width: 50px;
      text-align: center;
    }

    input[type="range"] {
      flex-grow: 1;
    }

    #minimize-controls-toggle {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      border: none;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem 1rem;
      border-radius: 10px 10px 0 0;
    }

    /* Story Maker */
    #story-maker-container {
      position: fixed;
      inset: 0;
      z-index: 150;
      display: none;
      justify-content: center;
      align-items: center;
      pointer-events: all;
      padding-top: env(safe-area-inset-top, 0);
      padding-right: env(safe-area-inset-right, 0);
      padding-bottom: env(safe-area-inset-bottom, 0);
      padding-left: env(safe-area-inset-left, 0);
    }

    #story-maker-grid {
      display: grid;
      grid-template-columns: 350px 1fr;
      gap: 2rem;
      width: 90%;
      max-width: 1200px;
    }

    #story-maker-left-panel {
      background-color: rgba(30, 30, 30, 0.7);
      padding: 1rem;
      border-radius: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .story-maker-dropzone {
      width: 100%;
      aspect-ratio: 16/9;
      background: #333;
      border: 3px dashed #666;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.5rem;
      position: relative;
    }

    .story-maker-dropzone video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 6px;
    }

    #story-maker-effects {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .effect-btn {
      background-color: #4a4a4a;
      border: 2px solid transparent;
    }

    .effect-btn.active {
      border-color: #3498db;
    }

    #story-maker-clip-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    #story-maker-clue {
      background-color: rgba(0, 0, 0, 0.3);
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      font-size: 1.5rem;
      font-style: italic;
      color: black;
    }

    #story-maker-clip-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    .story-maker-clip-cell {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
    }

    .story-maker-clip-cell video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border: 2px solid #555;
      border-radius: 8px;
      cursor: grab;
    }

    .clip-arrow {
      position: absolute;
      background: rgba(0, 0, 0, 0.5);
      border: none;
      color: white;
      font-size: 1rem;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
    }

    .clip-arrow-left {
      left: 5px;
      top: 50%;
      transform: translateY(-50%);
    }

    .clip-arrow-right {
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
    }

    #movie-playback-overlay {
      pointer-events: none;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.7), transparent, transparent, rgba(0, 0, 0, 0.7));
    }

    .movie-sentence-display {
      position: absolute;
      font-size: 2.5rem;
      text-align: center;
      padding: 2rem;
      text-shadow: 2px 2px 8px black;
      transition: opacity 0.5s;
      opacity: 0;
    }

    #story-maker-bg {
      position: fixed;
      inset: 0;
      z-index: 149;
      background-color: white;
      display: none;
      transition: background-color 0.5s;
    }

    #story-maker-progress {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
      background-color: black;
      transform-origin: left;
      transform: scaleX(0);
      transition: transform 180s linear;
    }

    #scene-timer-display {
      font-size: 2rem;
      font-weight: bold;
      color: black;
    }

    /* Scoreboard */
    #scoreboard-container {
      position: fixed;
      top: 1rem;
      left: 1rem;
      top: max(1rem, env(safe-area-inset-top, 1rem));
      left: max(1rem, env(safe-area-inset-left, 1rem));
      z-index: 150;
      background: rgba(0, 0, 0, 0.6);
      padding: 0.5rem;
      border-radius: 1rem;
      transition: opacity 0.3s;
      cursor: move;
    }

    #scoreboard-header {
      display: flex;
      justify-content: flex-end;
    }

    #scoreboard-close-btn {
      background: none;
      border: none;
      color: #aaa;
      cursor: pointer;
      padding: 0 5px;
    }

    #scores-wrapper {
      display: flex;
      gap: 1rem;
      padding: 0 0.5rem 0.5rem 0.5rem;
    }

    .score-widget {
      position: relative;
      padding: 0.5rem;
      border-radius: 0.5rem;
      min-width: 80px;
      text-align: center;
    }

    .score-display {
      font-size: 2rem;
      font-weight: bold;
    }

    .score-controls button {
      position: absolute;
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 0.8rem;
      opacity: 0.5;
      transition: opacity 0.2s;
    }

    .score-widget:hover .score-controls button {
      opacity: 1;
    }

    .score-plus {
      top: 2px;
      right: 2px;
    }

    .score-minus {
      bottom: 2px;
      right: 2px;
    }

    .score-hide {
      top: 2px;
      left: 2px;
    }

    .score-reset {
      bottom: 2px;
      left: 2px;
    }

    /* Trivia Game */
    #trivia-overlay {
      background-color: rgba(0, 0, 0, 0.8);
      padding: 2rem;
      border-radius: 1rem;
      width: 90%;
      max-width: 800px;
      pointer-events: all;
    }

    #trivia-question {
      font-size: 2rem;
      margin-bottom: 2rem;
      text-align: center;
    }

    #trivia-answers {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    .trivia-answer-btn {
      background-color: #4a4a4a;
      padding: 1rem;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .trivia-answer-btn:hover {
      background-color: #6a6a6a;
    }

    #trivia-player-indicator {
      position: absolute;
      top: 1rem;
      left: 1rem;
      font-size: 1.5rem;
    }

    /* Draggable/Resizable Bingo Game */
    .bingo-card-widget {
      position: fixed;
      z-index: 160;
      background: rgba(20, 20, 20, 0.9);
      border-radius: 6px;
      box-shadow: 0 3px 15px rgba(0, 0, 0, 0.6);
      width: 200px;
      min-width: 160px;
      min-height: 160px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: both;
    }

    .bingo-card-header {
      padding: 3px 6px;
      background: rgba(0, 0, 0, 0.6);
      cursor: move;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: white;
      font-weight: bold;
      font-size: 0.85rem;
    }

    .bingo-card-close-btn {
      cursor: pointer;
      font-size: 1rem;
      padding: 0 3px;
      background: none;
      border: none;
      color: #aaa;
      line-height: 1;
    }

    .bingo-card-close-btn:hover {
      color: white;
    }

    .bingo-grid-container {
      padding: 6px;
      flex-grow: 1;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 3px;
    }

    .bingo-grid-container .cell {
      background: #444;
      border-radius: 3px;
      cursor: pointer;
      font-size: 0.6rem;
      padding: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      transition: background-color 0.2s;
      overflow: hidden;
      word-break: break-word;
      line-height: 1.1;
    }

    .bingo-grid-container .cell.marked {
      border: 2px solid white;
    }

    /* General Panel Styles */
    .panel h3 {
      font-size: 1.1rem;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
    }

    .panel label {
      display: block;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
      color: #ccc;
    }

    .panel input[type="checkbox"] {
      margin-right: 8px;
    }

    .panel select,
    .panel input[type="number"],
    .panel input[type="text"],
    .panel textarea {
      width: 100%;
      background-color: #3a3a3a;
      border: 1px solid #5a5a5a;
      color: #e2e8f0;
      border-radius: 0.25rem;
      padding: 0.5rem;
    }

    .panel button,
    .modal-action-btn {
      background-color: #5a5a5a;
      color: white;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      transition: background-color 0.2s;
      width: 100%;
      margin-top: 0.5rem;
      border: none;
      font-weight: bold;
    }

    .panel button:disabled,
    .modal-action-btn:disabled {
      background-color: #444;
      color: #888;
      cursor: not-allowed;
    }

    .panel button:hover:not(:disabled),
    .modal-action-btn:hover:not(:disabled) {
      background-color: #7a7a7a;
    }

    /* Challenge Grid & Modal */
    #challenge-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-auto-rows: minmax(0, 1fr);
      gap: 10px;
      flex-grow: 1;
    }

    .challenge-square {
      aspect-ratio: 1 / 1;
      background-color: #3a3a3a;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, background-color 0.2s;
      position: relative;
      overflow: hidden;
    }

    .challenge-square .status-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      color: white;
    }

    .challenge-square.completed .status-overlay {
      background-color: rgba(46, 204, 113, 0.7);
      opacity: 1;
      visibility: visible;
    }

    .challenge-square.failed .status-overlay {
      background-color: rgba(231, 76, 60, 0.7);
      opacity: 1;
      visibility: visible;
    }

    .challenge-square.completed,
    .challenge-square.failed {
      cursor: not-allowed;
    }

    @keyframes bonusPulse {
      0% {
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 0;
      }
      50% {
        transform: translate(-50%, -50%) scale(1.1);
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }


    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    #task-modal-overlay {
      z-index: 300;
      background-color: rgba(0, 0, 0, 0.9);
    }

    #task-modal-content {
      background-color: #1f1f1f;
      padding: 2rem;
      padding-top: max(2rem, env(safe-area-inset-top, 2rem));
      padding-right: max(2rem, env(safe-area-inset-right, 2rem));
      padding-bottom: max(2rem, env(safe-area-inset-bottom, 2rem));
      padding-left: max(2rem, env(safe-area-inset-left, 2rem));
      border-radius: 1rem;
      width: 90%;
      max-width: 800px;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      max-height: 90vh;
      position: relative;
      transition: background-color 0.3s;
    }

    #task-modal-body {
      overflow-y: auto;
      padding-right: 1rem;
      text-align: center;
    }

    #task-modal-title {
      font-size: 1.75rem;
      border-bottom: 1px solid #444;
      padding-bottom: 0.5rem;
      margin: 0;
      text-align: center;
    }

    #task-modal-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      color: #aaa;
      font-size: 2rem;
      cursor: pointer;
      line-height: 1;
      transition: color 0.2s;
      z-index: 10;
      padding: 0.5rem;
      min-width: 44px;
      min-height: 44px;
    }

    #task-modal-close:hover {
      color: white;
    }

    /* Toast Notification System */
    #toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 400;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
      padding-top: env(safe-area-inset-top, 20px);
      padding-right: env(safe-area-inset-right, 20px);
    }

    .toast {
      background: rgba(31, 31, 31, 0.95);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      min-width: 250px;
      max-width: 400px;
      pointer-events: auto;
      animation: toastSlideIn 0.3s ease-out;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      border-left: 4px solid #3498db;
    }

    .toast.success {
      border-left-color: #27ae60;
    }

    .toast.error {
      border-left-color: #e74c3c;
    }

    .toast.warning {
      border-left-color: #f39c12;
    }

    .toast.info {
      border-left-color: #3498db;
    }

    @keyframes toastSlideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .toast.removing {
      animation: toastSlideOut 0.3s ease-in forwards;
    }

    @keyframes toastSlideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(400px);
        opacity: 0;
      }
    }

    .task-option-btn {
      background-color: #4a4a4a;
      padding: 1rem;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: background-color 0.2s;
      text-align: left;
      width: 100%;
      border: none;
      color: white;
      font-size: 1rem;
    }

    .task-option-btn:hover:not(:disabled) {
      background-color: #6a6a6a;
    }

    .task-option-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .task-option-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    #start-challenge-btn {
      max-width: 200px;
      margin: 1rem auto 0 auto;
    }

    .task-input-field {
      color: black;
      font-size: 1.1rem;
      padding: 1rem; /* Larger touch target */
      min-height: 3rem; /* Fat UI for iPad */
    }

    .voice-input-btn {
      background: #3498db;
      color: white;
      border: none;
      border-radius: 50%;
      width: 3rem;
      height: 3rem;
      font-size: 1.5rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
      margin-left: 0.5rem;
    }

    .voice-input-btn:hover {
      background: #2980b9;
    }

    .voice-input-btn.listening {
      background: #e74c3c;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .input-with-voice {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    #task-modal-timer {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 1rem;
    }

    /* Match Pairs Game */
    .emoji-grid {
      display: grid;
      gap: 5px;
      max-width: 400px;
      margin: auto;
    }

    .emoji-grid.grid-cols-4 {
      grid-template-columns: repeat(4, 1fr);
    }

    .emoji-grid.grid-cols-5 {
      grid-template-columns: repeat(5, 1fr);
    }

    .emoji-cell {
      aspect-ratio: 1/1;
      background: #444;
      border-radius: 8px;
      font-size: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.2s;
      transform-style: preserve-3d;
    }

    .emoji-cell .emoji-content {
      backface-visibility: hidden;
      transition: opacity 0.2s;
      opacity: 0;
    }

    .emoji-cell.flipped {
      transform: rotateY(180deg);
      background-color: #666;
    }

    .emoji-cell.flipped .emoji-content {
      opacity: 1;
      transform: rotateY(180deg);
    }

    .emoji-cell.matched {
      background-color: #27ae60;
      opacity: 0.5;
      cursor: default;
    }

    /* Bingo Builder */
    #bingo-builder-master-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 5px;
      max-height: 40vh;
      overflow-y: auto;
      padding: 5px;
      background: #111;
      border-radius: 5px;
      margin-bottom: 1rem;
    }

    #bingo-builder-master-list .bingo-item {
      background: #333;
      padding: 8px;
      font-size: 0.7rem;
      border-radius: 3px;
      cursor: pointer;
      text-align: center;
    }

    #bingo-builder-master-list .bingo-item.selected {
      background: #3498db;
    }

    #my-bingo-card-preview {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 3px;
      margin-top: 0.5rem;
    }

    #my-bingo-card-preview .cell {
      background: #444;
      border-radius: 3px;
      aspect-ratio: 3/2;
      font-size: 0.6rem;
      padding: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      word-break: break-word;
      line-height: 1.1;
    }

    /* Memory Game */
    #memory-video-player-container {
      width: 100%;
      max-width: 500px;
      margin: 0 auto 1rem auto;
      aspect-ratio: 16/9;
      background: #000;
    }

    #memory-video-player-container video {
      width: 100%;
      height: 100%;
    }

    .memory-clip-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.5rem;
      max-width: 600px;
      margin: auto;
    }

    .memory-clip-thumbnail {
      aspect-ratio: 16/9;
      position: relative;
      cursor: pointer;
    }

    .memory-clip-thumbnail video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 8px;
      border: 2px solid transparent;
      pointer-events: none;
    }

    .memory-clip-thumbnail:hover video {
      border-color: #3498db;
    }

    .memory-clip-thumbnail.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* NEW: Clip Sequencer */
    .sequencer-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
    }

    .sequencer-drop-zones {
      display: flex;
      gap: 0.5rem;
      padding: 0.5rem;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
    }

    .sequencer-drop-zone {
      width: 120px;
      height: 67.5px;
      border: 2px dashed #666;
      border-radius: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #888;
    }

    .sequencer-drop-zone.over {
      border-color: #fff;
      background: rgba(255, 255, 255, 0.1);
    }

    .sequencer-clips-pool {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
      min-height: 80px;
    }

    .sequencer-draggable-clip {
      width: 120px;
      height: 67.5px;
      cursor: grab;
    }

    .sequencer-draggable-clip video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 5px;
      pointer-events: none;
    }

    /* NEW: Reflex Test */
    .reflex-test-container {
      position: relative;
      width: 100%;
      max-width: 600px;
      margin: auto;
      aspect-ratio: 16/9;
    }

    .reflex-test-video {
      width: 100%;
      height: 100%;
    }

    .reflex-test-symbol {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 8rem;
      text-shadow: 0 0 20px black;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s;
    }

    .reflex-test-symbol.visible {
      opacity: 1;
    }

    /* Main Score Display */
    #main-score-container {
      position: fixed;
      top: 1rem;
      left: 50%;
      z-index: 155;
      background: rgba(0, 0, 0, 0.7);
      padding: 0.5rem 1rem;
      border-radius: 1rem;
      font-size: 1.5rem;
      font-weight: bold;
      color: #3498db;
      border: 2px solid #3498db;
      display: flex;
      gap: 1rem;
      align-items: center;
      animation: float 6s ease-in-out infinite;
    }

    #gemini-key-container {
      position: fixed;
      top: 1rem;
      right: 1rem;
      z-index: 210;
      display: none; /* Hidden - Gemini integration removed */
      align-items: center;
      gap: 0.5rem;
      background: rgba(0, 0, 0, 0.7);
      padding: 0.5rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid #3498db;
    }

    #gemini-key-container label {
      font-size: 0.9rem;
      color: #9ca3af;
    }

    #gemini-api-key {
      width: 180px;
      background: #1f2937;
      border: 1px solid #4b5563;
      border-radius: 0.5rem;
      padding: 0.35rem 0.5rem;
      color: #e2e8f0;
    }

    #gemini-key-save {
      background: #2563eb;
      border: none;
      color: white;
      border-radius: 0.5rem;
      padding: 0.35rem 0.75rem;
      cursor: pointer;
      transition: background 0.2s;
    }

    #gemini-key-save:hover {
      background: #1d4ed8;
    }

    #gemini-key-status {
      font-size: 0.75rem;
      color: #fbbf24;
    }

    #challenge-status-bar {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    #challenge-turn-indicator {
      border: 2px solid #3498db;
      border-radius: 0.75rem;
      padding: 0.4rem 0.75rem;
      text-align: center;
      font-weight: 600;
      font-size: 1rem;
      color: #3498db;
      background: rgba(0, 0, 0, 0.4);
    }

    #challenge-player-list {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .challenge-player-card {
      border: 2px solid transparent;
      border-radius: 0.75rem;
      padding: 0.5rem 0.75rem;
      background: rgba(17, 24, 39, 0.7);
      min-width: 120px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .challenge-player-card.active {
      transform: translateY(-4px);
      box-shadow: 0 0 12px rgba(52, 152, 219, 0.4);
    }

    .challenge-player-card .player-label {
      font-weight: 600;
    }

    .challenge-player-card .player-score {
      font-size: 1.25rem;
      font-weight: 700;
    }

    .challenge-square[data-owner="0"] {
      border: 3px solid #3498db;
      box-shadow: 0 0 15px rgba(52, 152, 219, 0.4);
    }

    .challenge-square[data-owner="1"] {
      border: 3px solid #e74c3c;
      box-shadow: 0 0 15px rgba(231, 76, 60, 0.4);
    }

    .challenge-square[data-owner="2"] {
      border: 3px solid #2ecc71;
      box-shadow: 0 0 15px rgba(46, 204, 113, 0.4);
    }

    .challenge-square[data-owner="3"] {
      border: 3px solid #f39c12;
      box-shadow: 0 0 15px rgba(243, 156, 18, 0.4);
    }
    
    /* iPad and touch device optimizations */
    @media (hover: none) and (pointer: coarse) {
      /* Increase touch target sizes for iPad */
      .task-option-btn {
        padding: 1.25rem;
        font-size: 1.1rem;
      }
      
      .modal-action-btn {
        padding: 1rem 1.5rem;
        min-height: 48px;
      }
      
      .challenge-square {
        /* Ensure adequate touch target size */
        min-width: 48px;
        min-height: 48px;
      }
      
      /* Prevent double-tap zoom */
      * {
        touch-action: manipulation;
      }
    }
  </style>
</head>

<body>
  <div class="video-full-screen"><video id="mainVideo" muted playsinline></video></div>
  <div id="story-maker-bg">
    <div id="story-maker-progress"></div>
  </div>
  <div id="breathingOverlay" class="overlay">
    <div class="overlay-timer"></div>
    <div class="overlay-text"></div>
  </div>
  <div id="countdownOverlay" class="overlay countdown-overlay"></div>
  <div id="completionOverlay" class="overlay completion-overlay">Complete!</div>
  <div id="on-screen-tally-container"></div>
  <div id="bingo-cards-overlay-container"></div>
  <div id="trivia-game-overlay" class="overlay"></div>
  <div id="scoreboard-container" class="hidden"></div>
  <div id="gemini-key-container">
    <label for="gemini-api-key">Gemini Key</label>
    <input type="password" id="gemini-api-key" placeholder="Paste key" autocomplete="off">
    <button id="gemini-key-save">Save</button>
    <span id="gemini-key-status"></span>
  </div>
  <div id="story-maker-container"></div>
  <div id="movie-playback-overlay" class="overlay"></div>

  <div id="task-modal-overlay" class="overlay">
    <div id="task-modal-content">
      <button id="task-modal-close">&times;</button>
      <h2 id="task-modal-title">Task Title</h2>
      <div id="task-modal-body"></div>
    </div>
  </div>

  <div id="toast-container"></div>

  <div id="main-score-container">
    <span>Score: <span id="main-score-value">0</span></span>
    <span>Multiplier: <span id="main-score-multiplier">1.0</span>x</span>
  </div>

  <div id="media-controls-container">
    <button id="minimize-controls-toggle" title="Toggle Controls">üîΩ</button>
    <div id="mediaControlsOverlay" class="media-controls-overlay">
      <div class="media-controls-content">
        <div class="progress-volume-row">
          <span id="currentTime" class="time-display">0:00</span>
          <input type="range" id="progressBar" value="0" min="0" max="100" step="0.1">
          <span id="durationTime" class="time-display">0:00</span>
        </div>
        <div class="media-controls-buttons">
          <button id="prevButton" title="Previous Video">‚èÆÔ∏è</button>
          <button id="skipBack10s" title="Back 10s">‚è™</button>
          <button id="playPauseButton" title="Play/Pause">‚ñ∂Ô∏è</button>
          <button id="skipFwd10s" title="Forward 10s">‚è©</button>
          <button id="nextButton" title="Next Video">‚è≠Ô∏è</button>
          <input type="range" id="volumeSlider" value="0" min="0" max="100" title="Volume" style="max-width: 100px;">
        </div>
      </div>
    </div>
  </div>

  <div id="challenge-panel" class="panel left-panel">
    <div class="panel-header">
      <h2 id="title-challenge" class="title-yellow">The Forecast</h2>
    </div>
    <div style="margin-bottom: 1rem;">
      <h3 style="font-size: 0.9rem; margin-bottom: 0.5rem;">Player Setup:</h3>
      <div style="display: flex; flex-direction: column; gap: 0.5rem;">
        <div style="display: flex; gap: 0.5rem; align-items: center;">
          <input type="checkbox" id="player1-active" checked disabled style="cursor: not-allowed;">
          <input type="text" id="player1-name-input" value="Player 1" placeholder="Player 1 Name" style="flex: 1; padding: 0.5rem; background: rgba(52, 152, 219, 0.2); border: 1px solid #3498db; border-radius: 4px; color: white;">
          <select id="player1-type" style="padding: 0.5rem; background: rgba(52, 152, 219, 0.2); border: 1px solid #3498db; border-radius: 4px; color: white;">
            <option value="Human">Human</option>
            <option value="AI">AI</option>
          </select>
        </div>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
          <input type="checkbox" id="player2-active" checked style="cursor: pointer;">
          <input type="text" id="player2-name-input" value="Player 2" placeholder="Player 2 Name" style="flex: 1; padding: 0.5rem; background: rgba(231, 76, 60, 0.2); border: 1px solid #e74c3c; border-radius: 4px; color: white;">
          <select id="player2-type" style="padding: 0.5rem; background: rgba(231, 76, 60, 0.2); border: 1px solid #e74c3c; border-radius: 4px; color: white;">
            <option value="Human">Human</option>
            <option value="AI">AI</option>
          </select>
        </div>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
          <input type="checkbox" id="player3-active" style="cursor: pointer;">
          <input type="text" id="player3-name-input" value="Player 3" placeholder="Player 3 Name" style="flex: 1; padding: 0.5rem; background: rgba(46, 204, 113, 0.2); border: 1px solid #2ecc71; border-radius: 4px; color: white;">
          <select id="player3-type" style="padding: 0.5rem; background: rgba(46, 204, 113, 0.2); border: 1px solid #2ecc71; border-radius: 4px; color: white;">
            <option value="Human">Human</option>
            <option value="AI">AI</option>
          </select>
        </div>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
          <input type="checkbox" id="player4-active" style="cursor: pointer;">
          <input type="text" id="player4-name-input" value="Player 4" placeholder="Player 4 Name" style="flex: 1; padding: 0.5rem; background: rgba(243, 156, 18, 0.2); border: 1px solid #f39c12; border-radius: 4px; color: white;">
          <select id="player4-type" style="padding: 0.5rem; background: rgba(243, 156, 18, 0.2); border: 1px solid #f39c12; border-radius: 4px; color: white;">
            <option value="Human">Human</option>
            <option value="AI">AI</option>
          </select>
        </div>
      </div>
    </div>
    <div id="challenge-status-bar">
      <div id="challenge-turn-indicator"></div>
      <div id="challenge-player-list"></div>
    </div>
    <div id="challenge-grid"></div>
  </div>

  <div id="panel-playback-settings" class="panel right-panel">
    <div class="panel-header">
      <h2 id="title-playback">Atmosphere Control</h2>
    </div>
    <h3>Upload from Local Drive</h3>
    <input type="file" id="videoInput" multiple webkitdirectory directory
      class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-gray-500 file:text-white hover:file:bg-gray-600 cursor-pointer mb-4">
    <h3>Stream Change</h3>
    <div class="grid grid-cols-2 gap-2 text-sm">
      <label>Every <input type="number" id="intervalSeconds" value="30" class="w-full mt-1"> seconds</label>
      <label>Every <input type="number" id="intervalMinutes" value="" class="w-full mt-1"> minutes</label>
    </div>
    <button id="startIntervalChange">Start Streaming</button>
    <div class="mt-4 border-t border-gray-700 pt-4">
      <label><input type="checkbox" id="playRandomStart" checked>Play videos from random start</label>
      <label><input type="checkbox" id="shuffleOnLoad" checked>Shuffle playlist on load</label>
    </div>
  </div>
  <div id="panel-random-selector" class="panel right-panel">
    <div class="panel-header">
      <h2 id="title-selector">Cloud Seeding</h2>
    </div>
    <div id="random-video-grid" class="grid-cols-2 grid gap-2"></div>
    <button id="refresh-random-grid" class="mt-4">Reseed</button>
  </div>
  <div id="panel-breathing" class="panel right-panel">
    <div class="panel-header">
      <h2 id="title-breathing">Vapor Control</h2>
    </div>
    <div class="grid grid-cols-2 gap-4 mb-4">
      <div><label for="inhale">Inhale</label><input type="number" id="inhale" value="8" min="1"></div>
      <div><label for="hold">Hold</label><input type="number" id="hold" value="5" min="0"></div>
      <div><label for="exhale">Exhale</label><input type="number" id="exhale" value="5" min="1"></div>
      <div><label for="breaths">Breaths</label><input type="number" id="breaths" value="5" min="1"></div>
    </div>
    <div class="flex flex-col gap-2 text-sm mb-4">
      <label><input type="checkbox" id="changePerBreath">Change video per breath</label>
      <label><input type="checkbox" id="changePerPhase">Change video per phase</label>
    </div>
    <button id="startBreathingGuideButton">Start Breathing</button>
  </div>
  <div id="panel-countdown" class="panel right-panel">
    <div class="panel-header">
      <h2 id="title-countdown">Time Lapse</h2>
    </div>
    <label for="countdownTimerSeconds">Timer Duration (s)</label>
    <input type="number" id="countdownTimerSeconds" value="30" min="1" class="mb-2">
    <label for="countdownVideoChangeSeconds">Change Video Every (s)</label>
    <input type="number" id="countdownVideoChangeSeconds" value="" placeholder="Disabled" class="mb-4">
    <button id="startCountdownButton">Start Countdown</button>
  </div>
  <div id="panel-trivia" class="panel right-panel">
    <div class="panel-header">
      <h2 id="title-trivia">Brain Storm</h2>
    </div>
    <div class="flex items-center gap-2">
      <input type="text" id="trivia-theme" placeholder="Enter a theme..." class="flex-grow">
      <button id="random-trivia-theme-btn" title="Random Theme">‚ú®</button>
    </div>
    <label for="trivia-difficulty-slider" class="mt-4">Difficulty: <span id="difficulty-label">Fairly Well
        Known</span></label>
    <input type="range" id="trivia-difficulty-slider" min="1" max="10" value="5" class="w-full mb-2">
    <label><input type="checkbox" id="trivia-progressive"> Questions get harder</label>
    <label for="trivia-players" class="mt-4">Players:</label>
    <input type="number" id="trivia-players" value="1" min="1" max="4" class="mb-2">
    <label for="trivia-questions">Number of Questions:</label>
    <input type="number" id="trivia-questions" value="5" min="1" max="20" class="mb-2">
    <label for="trivia-speed-round">Speed Round (seconds, 0=off):</label>
    <input type="number" id="trivia-speed-round" value="0" min="0" class="mb-4">
    <button id="start-trivia-btn">Start the Brain Storm</button>
  </div>
  <div id="panel-guessing" class="panel right-panel">
    <div class="panel-header">
      <h2 id="title-guessing">Pressure Front</h2>
    </div>
    <div id="guessing-inputs-container">
      </div>
    <label for="guessTimerDuration">Round Duration (s):</label>
    <input type="number" id="guessTimerDuration" value="30" min="5" class="mb-2">
    <label for="guessVideoChangeSeconds">Change Video Every (s):</label>
    <input type="number" id="guessVideoChangeSeconds" value="5" min="1" class="mb-4">
    <button id="startGuessGameButton">Start Round</button>
  </div>
  <div id="panel-bingo" class="panel right-panel">
    <div class="panel-header">
      <h2 id="title-bingo">Atmospheric Bingo</h2>
    </div>
    <div id="bingo-setup">
      <label for="playerCount">Players:</label>
      <select id="playerCount" class="mb-2">
        <option value="1">1</option>
        <option value="2" selected>2</option>
        <option value="3">3</option>
        <option value="4">4</option>
      </select>
      <button id="setupBingoButton">New Game</button>
    </div>
    <div id="bingo-selection-active" class="hidden mt-2">
      <div id="bingo-turn-indicator" class="text-center font-bold mb-2"></div>
      <div id="bingo-master-list"></div>
      <button id="generateBingoCardsButton" class="mt-4" disabled>Generate Cards</button>
    </div>
  </div>
  <div id="panel-story-maker" class="panel right-panel">
    <div class="panel-header">
      <h2 id="title-story-maker">Dream Factory</h2>
    </div>
    <div class="flex items-center gap-2">
      <input type="text" id="story-maker-title" placeholder="e.g., The Cloudburst" class="flex-grow">
      <button id="generate-title-btn" title="Generate Title">‚ú®</button>
    </div>
    <label for="story-maker-scenes" class="mt-2">Number of Scenes (4-8):</label>
    <input type="number" id="story-maker-scenes" value="6" min="4" max="8" class="mb-2">
    <label for="story-maker-voice">Voice:</label>
    <div class="flex items-center gap-2">
      <select id="story-maker-voice" class="flex-grow"></select>
      <button id="preview-voice-btn" class="panel-toggle-button"
        style="width: 40px; height: 40px; font-size: 1.2rem;">üîä</button>
    </div>
    <label for="story-maker-font" class="mt-2">Font:</label>
    <select id="story-maker-font" class="mb-4">
      <option value="'Trajan Pro', serif">Trajan Pro</option>
      <option value="'Impact', sans-serif">Impact</option>
      <option value="'Cinzel', serif">Cinzel</option>
      <option value="'Bebas Neue', sans-serif">Bebas Neue</option>
    </select>
    <button id="generate-script-btn">Generate Dream Script</button>
  </div>
  
  <div id="panel-creative-challenges" class="panel right-panel">
    <div class="panel-header">
      <h2 id="title-creative-challenges">Creative Challenges</h2>
    </div>
    <h3>Upload Custom Challenges</h3>
    <p style="font-size: 0.9rem; margin-bottom: 0.5rem; opacity: 0.8;">Enter one challenge per line:</p>
    <textarea id="creative-challenges-input" rows="6" placeholder="Tell us your funniest story!
Act out a famous movie scene
Sing a song about clouds
Do your best celebrity impression" style="margin-bottom: 1rem;"></textarea>
    <button id="save-creative-challenges-btn">Save Challenges</button>
    <div id="saved-challenges-list" style="margin-top: 1rem;">
      <h3>Saved Challenges:</h3>
      <div id="challenges-display" style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 0.5rem; border-radius: 4px; margin-top: 0.5rem;">
        <p style="opacity: 0.6; font-style: italic;">No challenges saved yet.</p>
      </div>
      <button id="clear-challenges-btn" class="mt-2" style="background-color: #e74c3c;">Clear All</button>
    </div>
  </div>

  <div id="panel-film-uploader" class="panel right-panel">
    <div class="panel-header">
      <h2 id="title-film-uploader">Film Stats Uploader üìä</h2>
    </div>
    <h3>Upload Film Data</h3>
    <p style="font-size: 0.9rem; margin-bottom: 0.5rem; opacity: 0.8;">Paste film titles and view counts (one per line, format: "Title|Views"):</p>
    <textarea id="film-data-input" rows="8" placeholder="The Dark Knight|2500000
Inception|1800000
Pulp Fiction|1600000
The Matrix|2200000
Fight Club|1400000" style="margin-bottom: 1rem; font-family: monospace;"></textarea>
    <button id="save-film-data-btn">Save Film Data</button>
    <div id="saved-film-data-list" style="margin-top: 1rem;">
      <h3>Saved Films: <span id="film-count">0</span></h3>
      <div id="film-data-display" style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 0.5rem; border-radius: 4px; margin-top: 0.5rem; font-size: 0.8rem;">
        <p style="opacity: 0.6; font-style: italic;">No film data saved yet.</p>
      </div>
      <button id="clear-film-data-btn" class="mt-2" style="background-color: #e74c3c;">Clear All</button>
    </div>
    <p style="font-size: 0.8rem; margin-top: 1rem; opacity: 0.7; font-style: italic;">
      üí° This data will be used in the "Higher or Lower" challenge
    </p>
  </div>

  <div class="panel-toggle-bar left-bar">
    <button class="panel-toggle-button" data-panel="challenge-panel" data-color="yellow" title="The Forecast">üèÜ</button>
  </div>
  <div class="panel-toggle-bar right-bar">
    <button class="panel-toggle-button" data-panel="panel-playback-settings" data-color="red"
      title="Atmosphere Control">üîÑ</button>
    <button class="panel-toggle-button" id="selector-toggle-btn" data-panel="panel-random-selector"
      data-color="orange" title="Cloud Seeding">üéûÔ∏è</button>
    <button class="panel-toggle-button" data-panel="panel-breathing" data-color="yellow" title="Vapor Control">üí®</button>
    <button class="panel-toggle-button" data-panel="panel-countdown" data-color="green" title="Time Lapse">‚è±Ô∏è</button>
    <button class="panel-toggle-button" data-panel="panel-trivia" data-color="blue" title="Brain Storm">üß†</button>
    <button class="panel-toggle-button" data-panel="panel-guessing" data-color="indigo" title="Pressure Front">üçÜ</button>
    <button class="panel-toggle-button" data-panel="panel-bingo" data-color="violet"
      title="Atmospheric Bingo">üé≤</button>
    <button class="panel-toggle-button" data-panel="panel-creative-challenges" data-color="indigo"
      title="Creative Challenges">üí°</button>
    <button class="panel-toggle-button" data-panel="panel-film-uploader" data-color="blue"
      title="Film Stats Uploader">üìä</button>
    <!-- Dream Factory removed - AI integration disabled -->
  </div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
          // =============================================================================
          // CLOUD 9 VIDEO PLAYER - FULL VERSION (index.html)
          // =============================================================================
          // NOTE: This file shares ~90% of code with newq.html (simplified version)
          // When making changes, consider if they should apply to both files.
          // See CODE_MAINTENANCE.md for guidelines on maintaining both versions.
          // =============================================================================

          // --- CODE FIX & THEME REFORMAT COMPLETE ---
          // 1. Fixed a missing comma in the `configs` array in `setupMatchPairsTask`.
          // 2. Replaced broken image links in the challenge grid with challenge icons.
          // 3. Updated text and prompts throughout the UI for a "Cloud" theme.
          // 4. Cleaned up the emoji list for the Match Pairs game.

          // --- DOM Elements ---
          const mainVideo = document.getElementById('mainVideo');
          const videoInput = document.getElementById('videoInput');
          const panelToggles = document.querySelectorAll('.panel-toggle-button');
          const panels = document.querySelectorAll('.panel');
          const onScreenTallyContainer = document.getElementById('on-screen-tally-container');
          const body = document.body;
          const bingoCardsOverlayContainer = document.getElementById('bingo-cards-overlay-container');
          const triviaGameOverlay = document.getElementById('trivia-game-overlay');
          const scoreboardContainer = document.getElementById('scoreboard-container');
          const selectorToggleBtn = document.getElementById('selector-toggle-btn');
          const storyMakerContainer = document.getElementById('story-maker-container');
          const storyMakerVoiceSelect = document.getElementById('story-maker-voice');
          const geminiKeyInput = document.getElementById('gemini-api-key');
          const geminiKeySaveBtn = document.getElementById('gemini-key-save');
          const geminiKeyStatus = document.getElementById('gemini-key-status');
          const challengeTurnIndicator = document.getElementById('challenge-turn-indicator');
          const challengePlayerList = document.getElementById('challenge-player-list');

          // --- Initialize Twemoji to replace all emojis with SVG images ---
          if (typeof twemoji !== 'undefined') {
            twemoji.parse(document.body, {
              folder: 'svg',
              ext: '.svg'
            });
          }

          // --- Challenge Grid Elements & State ---
          const challengeGrid = document.getElementById('challenge-grid');
          const taskModalOverlay = document.getElementById('task-modal-overlay');
          const taskModalContent = document.getElementById('task-modal-content');
          const taskModalTitle = document.getElementById('task-modal-title');
          const taskModalBody = document.getElementById('task-modal-body');
          const taskModalCloseBtn = document.getElementById('task-modal-close');
          let activeTaskElement = null;
          let modalTimer = null;
          let isTaskCompleted = false;

          // --- Scoring Elements & State ---
          const mainScoreValue = document.getElementById('main-score-value');
          const mainScoreMultiplier = document.getElementById('main-score-multiplier');
          let totalScore = 0;
          let scoreMultiplier = 1.0;
          let scoreDecayInterval = null;

          // --- Toast Notification System ---
          const toastContainer = document.getElementById('toast-container');
          
          function showToast(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icon = {
              success: '‚úì',
              error: '‚úï',
              warning: '‚ö†',
              info: '‚Ñπ'
            }[type] || '‚Ñπ';
            
            toast.innerHTML = `<span style="font-size: 1.2rem;">${icon}</span><span>${message}</span>`;
            toastContainer.appendChild(toast);
            
            setTimeout(() => {
              toast.classList.add('removing');
              setTimeout(() => {
                if (toast.parentNode) {
                  toast.parentNode.removeChild(toast);
                }
              }, 300);
            }, duration);
          }

          // --- THEME UPDATE: Cloud-themed categories ---
          const challengeCategories = [
           ["Cinematic Classics üé¨", "Underground Eats üçî", "Mythical Realms üêâ", "Bytes & Beeps üíæ", "Wild Kingdom üêæ", "Watery Wonders üåä", "Cosmic Conundrums üåå", "Artful Aesthetics üñºÔ∏è", "The Great Outdoors üèïÔ∏è", "Ancient History üè∫"],
           ["Pop Culture Puns üòÇ", "Kitchen Chemistry üß™", "Literary Giants ‚úçÔ∏è", "Global Gastronomy üåé", "Techno Trends ü§ñ", "Iconic Albums üíø", "Historical Figures üëë", "Scientific Scandals üî¨", "Futuristic Flicks üöÄ", "Architectural Marvels üèõÔ∏è"],
           ["Sporting Legends üèÖ", "Gourmet Grinds ‚òï", "Fashion Flashbacks üëó", "Digital Doodles üé®", "Spicy Spells üå∂Ô∏è", "Symphonic Stories üéª", "Cryptic Clues üïµÔ∏è", "Urban Legends üëª", "Board Game Bonanza üé≤", "Global Grooves üé∂"],
           ["Geographic Gems üó∫Ô∏è", "Prehistoric Pals ü¶ï", "Famous Feuds ü•ä", "Mythology Mayhem üè∫", "Viral Videos üé•", "Word Wizards üßô‚Äç‚ôÇÔ∏è", "Gassy Giants üí®", "Vintage Vibes üìª", "Food Fights üçé", "Sci-Fi Sagas üëΩ"],
           ["Mystical Monuments üèØ", "Elemental Power üî•", "Classic Cartoons üì∫", "Crime Scene Clues üîé", "Oceanic Odysseys üê≥", "Jungle Jive üêí", "Rhythmic Rhymes üé§", "Cloud Computing ‚òÅÔ∏è", "Culinary Concoctions üç≤", "Wacky World Records üèÜ"]
         ];

          // Challenges that require Gemini AI - DISABLED (AI integration removed)
          const AI_REQUIRED_CHALLENGES = new Set(['aiChallenge', 'audioAnagram']);

          const challengeTypes = [{
              type: 'matchPairs',
              name: 'Match Pairs',
              icon: '?'
            },

            {
              type: 'reflexTest',
              name: 'Reflex Test',
              icon: '?'
            },
            {
              type: 'blowback',
              name: 'Blowback',
              icon: '?'
            },
            {
              type: 'trivia',
              name: 'Trivia Challenge',
              icon: '‚ùì'
            },

            {
              type: 'bingo',
              name: 'Bingo',
              icon: '?'
            },
            // AI challenges disabled - aiChallenge removed
            {
              type: 'pressureFront',
              name: 'Pressure Front',
              icon: 'üçÜ'
            },
            {
              type: 'miniBingo',
              name: 'Mini Bingo',
              icon: 'üéØ'
            },

            {
              type: 'weatherGamble',
              name: 'Weather Gamble',
              icon: '‚õÖ'
            },
            // NEW MINI GAMES
            {
              type: 'videoClipDetective',
              name: 'Video Clip Detective',
              icon: 'üîç'
            },
            {
              type: 'clipOrderMemory',
              name: 'Clip Order Memory',
              icon: 'üé¨'
            },
            {
              type: 'avatarSequence',
              name: 'Avatar Sequence',
              icon: 'üß†'
            },
            {
              type: 'filmTitleScrambler',
              name: 'Film Title Scrambler',
              icon: 'üé¨'
            },
            {
              type: 'higherLowerViews',
              name: 'Higher or Lower',
              icon: 'üìä'
            },
            {
              type: 'iconClickHunt',
              name: 'Icon Click Hunt',
              icon: 'üéØ'
            },
            {
              type: 'triviaSpeedQuiz',
              name: 'Trivia Speed Quiz',
              icon: '‚ö°'
            },
            {
              type: 'paintSplatter',
              name: 'Paint Splatter',
              icon: 'üé®'
            },
            {
              type: 'timestampMatch',
              name: 'Timestamp Match',
              icon: '‚è±Ô∏è'
            },
            {
              type: 'videoQuarterPuzzle',
              name: 'Video Quarter Puzzle',
              icon: 'üß©'
            },
            {
              type: 'creativeChallenge',
              name: 'Creative Challenge',
              icon: 'üí°'
            },
            {
              type: 'splashClick',
              name: 'Emoji Clicker',
              icon: 'üí¶'
            }
          ];
          
          // Function to distribute challenges evenly with minimal clumping
          function distributeEvenly(challengeTypes, gridSize) {
            const result = [];
            const typeCount = challengeTypes.length;
            
            // Calculate how many times each challenge should appear
            const timesPerChallenge = Math.floor(gridSize / typeCount);
            const remainder = gridSize % typeCount;
            
            // Create a pool with the right number of each challenge
            const pool = [];
            challengeTypes.forEach((challenge, idx) => {
              const count = timesPerChallenge + (idx < remainder ? 1 : 0);
              for (let i = 0; i < count; i++) {
                pool.push(challenge);
              }
            });
            
            // Shuffle the pool
            for (let i = pool.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [pool[i], pool[j]] = [pool[j], pool[i]];
            }
            
            // Place challenges avoiding adjacent duplicates where possible
            // First item placed, now place remaining gridSize-1 items
            result.push(pool[0]);
            const remaining = pool.slice(1);
            
            for (let i = 0; i < gridSize - 1; i++) {
              const lastType = result[result.length - 1].type;
              
              // Try to find a different type
              let foundDifferent = false;
              for (let j = 0; j < remaining.length; j++) {
                if (remaining[j].type !== lastType) {
                  result.push(remaining[j]);
                  remaining.splice(j, 1);
                  foundDifferent = true;
                  break;
                }
              }
              
              // If no different type found, just use the first one
              if (!foundDifferent && remaining.length > 0) {
                result.push(remaining[0]);
                remaining.splice(0, 1);
              }
            }
            
            return result;
          }
          
          // Distribute 24 challenges evenly across the grid
          let challenges = distributeEvenly(challengeTypes, 24);
          
          // Add "pick the game" mechanics - convert some tiles to 3-choice options
          // Let's make every 4th tile (6 total) a 3-choice tile
          const threeChoiceIndices = [3, 7, 11, 15, 19, 23];
          threeChoiceIndices.forEach(index => {
            // Pick 3 distinct random challenges
            const availableTypes = [...challengeTypes];
            const threeChoices = [];
            for (let i = 0; i < 3; i++) {
              const randomIndex = Math.floor(Math.random() * availableTypes.length);
              threeChoices.push(availableTypes[randomIndex]);
              availableTypes.splice(randomIndex, 1); // Remove to ensure distinct
            }
            challenges[index] = threeChoices;
          });

          const challengeUIColors = {
            trivia: 'rgba(52, 152, 219, 0.5)',
            matchPairs: 'rgba(241, 196, 15, 0.5)',
            blowback: 'rgba(149, 165, 166, 0.5)',
            memory: 'rgba(230, 126, 34, 0.5)',
            bingo: 'rgba(231, 76, 60, 0.5)',
            aiChallenge: 'rgba(52, 73, 94, 0.5)',
            clipSequencer: 'rgba(211, 84, 0, 0.5)',
            audioAnagram: 'rgba(142, 68, 173, 0.5)',
            reflexTest: 'rgba(41, 128, 185, 0.5)',
            pressureFront: 'rgba(103, 58, 183, 0.5)',
            miniBingo: 'rgba(255, 87, 34, 0.5)',
            splashClick: 'rgba(0, 188, 212, 0.5)',
            weatherGamble: 'rgba(96, 125, 139, 0.5)',
            // NEW MINI GAMES
            videoClipDetective: 'rgba(255, 193, 7, 0.5)',
            clipOrderMemory: 'rgba(156, 39, 176, 0.5)',
            avatarSequence: 'rgba(76, 175, 80, 0.5)',
            filmTitleScrambler: 'rgba(233, 30, 99, 0.5)',
            higherLowerViews: 'rgba(63, 81, 181, 0.5)',
            iconClickHunt: 'rgba(0, 150, 136, 0.5)',
            triviaSpeedQuiz: 'rgba(255, 152, 0, 0.5)',
            paintSplatter: 'rgba(121, 85, 72, 0.5)',
            timestampMatch: 'rgba(96, 125, 139, 0.5)',
            videoQuarterPuzzle: 'rgba(156, 39, 176, 0.5)',
            creativeChallenge: 'rgba(103, 58, 183, 0.5)'
          };
          
          // Image shuffle-bag system - ensures all 34 PNGs are used before repeating
          let imageBag = [];
          const TOTAL_IMAGES = 34;
          
          function getNextImage() {
            if (imageBag.length === 0) {
              // Refill the bag with all 34 images
              imageBag = Array.from({ length: TOTAL_IMAGES }, (_, i) => i + 1);
              // Shuffle the bag
              for (let i = imageBag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [imageBag[i], imageBag[j]] = [imageBag[j], imageBag[i]];
              }
            }
            return imageBag.pop();
          }
          
          // Pre-assign images for the grid
          const gridImages = Array.from({ length: 24 }, () => getNextImage());

          const challengePlayers = [{
              name: 'Player 1',
              color: '#3498db',
              badge: 'P1',
              type: 'Human',
              active: true
            },
            {
              name: 'Player 2',
              color: '#e74c3c',
              badge: 'P2',
              type: 'Human',
              active: true
            },
            {
              name: 'Player 3',
              color: '#2ecc71',
              badge: 'P3',
              type: 'Human',
              active: false
            },
            {
              name: 'Player 4',
              color: '#f39c12',
              badge: 'P4',
              type: 'Human',
              active: false
            }
          ];
          let challengeScores = challengePlayers.map(() => 0);
          let currentChallengePlayerIndex = 0;
          
          // Track turns for creative challenge cadence
          let turnCounter = 0;
          let nextCreativeChallengeTurn = Math.floor(Math.random() * 3) + 3; // Random 3-5 turns
          
          // Track last attempted game type for each tile (for failure retry logic)
          let tileLastGameType = {};

          // Voice input support (Web Speech API)
          let recognition = null;
          if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-GB'; // UK English
          }

          function addVoiceInputToField(inputField) {
            if (!recognition) return; // Browser doesn't support speech recognition
            
            const container = document.createElement('div');
            container.className = 'input-with-voice';
            
            const voiceBtn = document.createElement('button');
            voiceBtn.className = 'voice-input-btn';
            voiceBtn.innerHTML = 'üé§';
            voiceBtn.type = 'button';
            voiceBtn.title = 'Voice input';
            
            // Wrap input field
            inputField.parentNode.insertBefore(container, inputField);
            container.appendChild(inputField);
            container.appendChild(voiceBtn);
            
            voiceBtn.addEventListener('click', () => {
              voiceBtn.classList.add('listening');
              
              recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                inputField.value = transcript;
                voiceBtn.classList.remove('listening');
              };
              
              recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                voiceBtn.classList.remove('listening');
              };
              
              recognition.onend = () => {
                voiceBtn.classList.remove('listening');
              };
              
              recognition.start();
            });
          }

          // =============================================================================
          // SHARED UTILITY FUNCTIONS
          // =============================================================================
          // The following functions are identical in both index.html and newq.html.
          // If you modify these functions, apply the same changes to both files.
          // See CODE_MAINTENANCE.md for the complete list of shared functions.
          // =============================================================================

          // Helper function to parse emojis in an element or the whole document
          function parseEmojis(element = document.body) {
            if (typeof twemoji !== 'undefined') {
              twemoji.parse(element, {
                folder: 'svg',
                ext: '.svg'
              });
            }
          }

          const GEMINI_STORAGE_KEY = 'gridgameGeminiKey';
          let geminiApiKey = '';

          function updateGeminiStatus(message, tone = 'info') {
            if (!geminiKeyStatus) return;
            const palette = {
              info: '#fbbf24',
              ok: '#2ecc71',
              error: '#f87171'
            };
            geminiKeyStatus.textContent = message;
            geminiKeyStatus.style.color = palette[tone] || palette.info;
          }

          function loadGeminiKey() {
            if (!geminiKeyInput) {
              return;
            }
            try {
              const stored = localStorage.getItem(GEMINI_STORAGE_KEY);
              if (stored) {
                geminiApiKey = stored;
                geminiKeyInput.value = geminiApiKey;
                updateGeminiStatus('Key ready', 'ok');
              } else {
                geminiApiKey = '';
                geminiKeyInput.value = '';
                updateGeminiStatus('Paste key to enable AI tasks', 'info');
              }
            } catch (error) {
              geminiApiKey = '';
              updateGeminiStatus('Storage unavailable', 'error');
            }
          }

          function persistGeminiKey(value) {
            geminiApiKey = (value || '').trim();
            if (geminiKeyInput) {
              geminiKeyInput.value = geminiApiKey;
            }
            try {
              if (geminiApiKey) {
                localStorage.setItem(GEMINI_STORAGE_KEY, geminiApiKey);
                updateGeminiStatus('Key saved', 'ok');
              } else {
                localStorage.removeItem(GEMINI_STORAGE_KEY);
                updateGeminiStatus('Key cleared', 'info');
              }
            } catch (error) {
              updateGeminiStatus('Storage unavailable', 'error');
            }
          }

          function renderChallengeHud() {
            if (challengeTurnIndicator && challengePlayers[currentChallengePlayerIndex]) {
              const activePlayer = challengePlayers[currentChallengePlayerIndex];
              challengeTurnIndicator.textContent = `${activePlayer.name}'s turn`;
              challengeTurnIndicator.style.borderColor = activePlayer.color;
              challengeTurnIndicator.style.color = activePlayer.color;
            }
            if (challengePlayerList) {
              const fragment = document.createDocumentFragment();
              challengePlayers.forEach((player, index) => {
                if (!player.active) return; // Skip inactive players
                
                const card = document.createElement('div');
                card.className = 'challenge-player-card';
                if (index === currentChallengePlayerIndex) {
                  card.classList.add('active');
                }
                card.style.borderColor = player.color;
                card.style.boxShadow = index === currentChallengePlayerIndex ? `0 0 12px ${player.color}66` : 'none';
                card.innerHTML = `<span class="player-label">${player.name}</span><span class="player-score">${challengeScores[index]}</span>`;
                fragment.appendChild(card);
              });
              challengePlayerList.innerHTML = '';
              challengePlayerList.appendChild(fragment);
            }
          }

          function resetChallengeGameState() {
            challengeScores = challengePlayers.map(() => 0);
            currentChallengePlayerIndex = 0;
            renderChallengeHud();
          }

          function advanceChallengeTurn() {
            // Only cycle through active players
            const activePlayers = challengePlayers.filter(p => p.active);
            if (activePlayers.length === 0) return; // Safety check
            
            // Find current player in active list
            let currentActiveIndex = activePlayers.findIndex((_, i) => {
              const playerIndex = challengePlayers.indexOf(activePlayers[i]);
              return playerIndex === currentChallengePlayerIndex;
            });
            
            // Move to next active player
            currentActiveIndex = (currentActiveIndex + 1) % activePlayers.length;
            currentChallengePlayerIndex = challengePlayers.indexOf(activePlayers[currentActiveIndex]);
            
            renderChallengeHud();
            
            // Increment turn counter and check for creative challenge trigger
            turnCounter++;
            if (turnCounter >= nextCreativeChallengeTurn) {
              // Trigger creative challenge
              turnCounter = 0;
              nextCreativeChallengeTurn = Math.floor(Math.random() * 3) + 3; // Next challenge in 3-5 turns
              
              // Delay slightly to let turn advance animation complete
              setTimeout(() => {
                showCreativeChallengePrompt();
              }, 500);
            }
          }
          
          function showCreativeChallengePrompt() {
            // Open creative challenge task
            openTaskModal('creativeChallenge', {});
          }

          if (geminiKeySaveBtn) {
            geminiKeySaveBtn.addEventListener('click', () => {
              persistGeminiKey(geminiKeyInput ? geminiKeyInput.value : '');
            });
          }
          if (geminiKeyInput) {
            geminiKeyInput.addEventListener('keydown', (event) => {
              if (event.key === 'Enter') {
                event.preventDefault();
                persistGeminiKey(geminiKeyInput.value);
              }
            });
          }
          loadGeminiKey();
          renderChallengeHud();


          // --- State ---
          let videoFiles = [];
          let currentVideoIndex = -1;
          let currentTimers = [];
          let videoChangeInterval = null;
          let intervalCountdownInterval = null;
          let panelInactivityTimer = null;
          
          // --- ObjectURL Tracking System ---
          let trackedObjectURLs = [];
          
          function createTrackedObjectURL(blob) {
            const url = URL.createObjectURL(blob);
            trackedObjectURLs.push(url);
            return url;
          }
          
          function revokeTrackedObjectURL(url) {
            const index = trackedObjectURLs.indexOf(url);
            if (index > -1) {
              URL.revokeObjectURL(url);
              trackedObjectURLs.splice(index, 1);
            }
          }
          
          function revokeAllTrackedObjectURLs() {
            trackedObjectURLs.forEach(url => URL.revokeObjectURL(url));
            trackedObjectURLs = [];
          }
          
          const playerColors = ['#3498db', '#2ecc71', '#f1c40f', '#e74c3c'];
          // --- THEME UPDATE: Cloud-themed bingo prompts ---
          const bingoPrompts = ["Someone blows smoke/vapor", "Four or more people", "Outside location", "Upside down position", "Costume or uniform", "Mirror reflection", "Someone wearing socks", "Body oil or shine", "Someone gets slapped",
            "Close-up of feet", "Whole body shot", "Overhead camera angle", "Tattoo visible", "Jewelry worn", "Someone is shaved", "Someone is hairy", "Bodybuilder type", "Twink type", "Beard or mustache", "Shaved head", "Long hair",
            "Finger in mouth", "Tongue visible", "Crotch grab", "Back arch", "Flexed biceps", "Abs in focus", "Hand gripping sheets", "White fluffy clouds (sheets)", "Black underwear", "Shoe left on", "Legs in the air", "Hands behind head",
            "Eye contact with camera", "Laugh or chuckle", "Someone spits", "Someone licks", "Someone winks", "Someone bites lip", "Slow stroke or touch", "Fast movement", "Eye roll", "Sunglasses", "Hat remains on", "Phone in frame",
            "Tripod or light visible", "Someone adjusts position", "Slap on thigh", "Bum close-up", "Back muscles in frame", "Chest close-up", "Open mouth with no sound", "Dirty talk subtitle", "Popper bottle visible", "Flickering like lightning",
            "Towel on bed", "Shoes visible on floor", "Muscle flex", "Shadow of cameraman", "Tattooed arm", "Long camera pan", "A heavy downpour", "Camera shakes", "Someone wipes sweat", "Someone grabs neck", "Head tilted back", "Someone whispers",
            "Audio cuts out", "Water bottle visible", "Colored LED light", "Music plays", "Scene fades in", "Scene fades out", "Video loops", "cumshot", "daddy", "struggleface", "parallel fucking", "deepthroating",
            "bottom more hung than top", "competative bottoms"
          ];
          let scores = [];
          let isVideoLoading = false;
          let storyMakerState = {
            script: [],
            timelineClips: []
          };

          // --- Gemini API ---
          async function callGemini(prompt, schema = null) {
            const keyInUse = geminiApiKey && geminiApiKey.trim();
            if (!keyInUse) {
              updateGeminiStatus('Add your Gemini key to run AI tasks', 'info');
              return null;
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${encodeURIComponent(keyInUse)}`;

            const payload = {
              contents: [{
                role: 'user',
                parts: [{
                  text: prompt
                }]
              }]
            };

            if (schema) {
              payload.generationConfig = {
                responseMimeType: 'application/json',
                responseSchema: schema
              };
            }

            let retries = 3;
            let delay = 1000;

            while (retries > 0) {
              try {
                const response = await fetch(apiUrl, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(payload)
                });

                if (response.ok) {
                  updateGeminiStatus('AI ready', 'ok');
                  const result = await response.json();
                  const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                  if (text) {
                    return text;
                  }
                  console.error('Invalid response structure from API:', result);
                  throw new Error('Invalid response structure from API.');
                }

                if (response.status === 401 || response.status === 403) {
                  updateGeminiStatus('Invalid or unauthorized key', 'error');
                  return null;
                }

                if (response.status === 429) {
                  updateGeminiStatus('Rate limited, retrying...', 'info');
                  await new Promise(res => setTimeout(res, delay));
                  delay *= 2;
                  retries--;
                  continue;
                }

                updateGeminiStatus(`API error ${response.status}`, 'error');
                throw new Error(`API call failed with status: ${response.status}`);
              } catch (error) {
                console.error('Gemini API Error:', error);
                retries--;
                if (retries <= 0) {
                  updateGeminiStatus('Gemini request failed', 'error');
                  return null;
                }
                await new Promise(res => setTimeout(res, delay));
                delay *= 2;
              }
            }
            return null;
          }

          // --- Free Trivia DB API ---
          // UK-appropriate trivia categories for adult general knowledge
          // Open Trivia DB category IDs: https://opentdb.com/api_category.php
          const ukTriviaCategories = [
            { id: 9, name: 'General Knowledge' },
            { id: 11, name: 'Film' },
            { id: 12, name: 'Music' },
            { id: 21, name: 'Sports' },
            { id: 22, name: 'Geography' },
            { id: 23, name: 'History' },
            { id: 17, name: 'Science & Nature' },
            { id: 18, name: 'Science: Computers' },
            { id: 14, name: 'Television' },
            { id: 10, name: 'Books' },
            { id: 26, name: 'Celebrities' },
            { id: 25, name: 'Art' }
          ];

          function getRandomUKCategory() {
            return ukTriviaCategories[Math.floor(Math.random() * ukTriviaCategories.length)];
          }

          async function fetchTriviaQuestions(amount = 5, category = null, difficulty = null) {
            // If no category specified, use random UK-appropriate category
            if (!category) {
              const randomCat = getRandomUKCategory();
              category = randomCat.id;
            }
            
            let apiUrl = `https://opentdb.com/api.php?amount=${amount}`;
            if (category) apiUrl += `&category=${category}`;
            if (difficulty) apiUrl += `&difficulty=${difficulty}`;
            apiUrl += '&type=multiple'; // Multiple choice questions

            try {
              const response = await fetch(apiUrl);
              if (!response.ok) {
                throw new Error(`Trivia API error: ${response.status}`);
              }
              const data = await response.json();
              
              if (data.response_code !== 0) {
                throw new Error('No trivia questions available');
              }

              // Transform the API response to match our internal format
              return data.results.map((q) => {
                const options = [...q.incorrect_answers, q.correct_answer];
                // Shuffle options
                for (let i = options.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [options[i], options[j]] = [options[j], options[i]];
                }
                const correctAnswerIndex = options.indexOf(q.correct_answer);
                
                return {
                  question: decodeHTMLEntities(q.question),
                  options: options.map(opt => decodeHTMLEntities(opt)),
                  correctAnswerIndex: correctAnswerIndex
                };
              });
            } catch (error) {
              console.error('Trivia API Error:', error);
              return null;
            }
          }

          function decodeHTMLEntities(text) {
            const doc = new DOMParser().parseFromString(text, 'text/html');
            return doc.documentElement.textContent;
          }

          // --- Utility Functions ---
          const clearAllTimers = () => {
            currentTimers.forEach(timer => {
              clearInterval(timer);
              clearTimeout(timer);
            });
            currentTimers = [];
            document.querySelectorAll('.overlay:not(#task-modal-overlay)').forEach(o => o.classList.remove('visible'));
            if (onScreenTallyContainer) {
              onScreenTallyContainer.classList.remove('visible');
            }
            if (videoChangeInterval) clearInterval(videoChangeInterval);
            if (intervalCountdownInterval) clearInterval(intervalCountdownInterval);
            videoChangeInterval = null;
            intervalCountdownInterval = null;
            selectorToggleBtn.innerHTML = 'üéûÔ∏è';
            parseEmojis(selectorToggleBtn);
          };
          const formatTime = (seconds) => {
            if (isNaN(seconds)) return "0:00";
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${min}:${sec}`;
          };

          // --- Scoring Functions ---
          function updateMainScore(points) {
            totalScore += Math.floor(points * scoreMultiplier);
            mainScoreValue.textContent = totalScore;
          }

          function startScoreDecay() {
            if (scoreDecayInterval) clearInterval(scoreDecayInterval);
            scoreDecayInterval = setInterval(() => {
              totalScore = Math.max(0, totalScore - 1); // Prevent score from going below 0
              mainScoreValue.textContent = totalScore;
            }, 100);
          }

          function stopScoreDecay() {
            if (scoreDecayInterval) clearInterval(scoreDecayInterval);
            scoreDecayInterval = null;
          }

          // --- Panel Logic ---
          function resetPanelInactivityTimer() {
            if (panelInactivityTimer) clearTimeout(panelInactivityTimer);
            panelInactivityTimer = setTimeout(() => {
              closeAllPanels();
            }, 15000);
          }

          const closeAllPanels = () => {
            panels.forEach(p => p.classList.remove('active'));
            panelToggles.forEach(t => {
              t.classList.remove('active');
              const color = t.dataset.color;
              if (color) t.classList.remove(`highlight-${color}`);
            });
            body.classList.remove('right-panel-active', 'left-panel-active');
            if (panelInactivityTimer) clearTimeout(panelInactivityTimer);
          };

          panelToggles.forEach(toggle => {
            toggle.addEventListener('click', () => {
              const targetPanelId = toggle.dataset.panel;
              const targetPanel = document.getElementById(targetPanelId);
              const isAlreadyActive = targetPanel.classList.contains('active');
              const color = toggle.dataset.color;
              const isLeftPanel = targetPanel.classList.contains('left-panel');

              closeAllPanels();

              if (!isAlreadyActive) {
                targetPanel.classList.add('active');
                toggle.classList.add('active');
                if (color) {
                  toggle.classList.add(`highlight-${color}`);
                  const title = targetPanel.querySelector('.panel-header h2');
                  if (title) {
                    title.className = ""; // reset
                    title.classList.add(`title-${color}`);
                  }
                }
                if (isLeftPanel) body.classList.add('left-panel-active');
                else body.classList.add('right-panel-active');
                resetPanelInactivityTimer();
              }
            });
          });
          panels.forEach(panel => {
            panel.addEventListener('mousemove', resetPanelInactivityTimer);
            panel.addEventListener('click', resetPanelInactivityTimer);
          });

          // --- Video & Playback Logic ---
          const advanceVideo = (direction) => {
            if (videoFiles.length === 0) return;
            currentVideoIndex = (currentVideoIndex + direction + videoFiles.length) % videoFiles.length;
            playVideoByIndex(currentVideoIndex);
          };
          const playVideoByIndex = (index, startTime = -1) => {
            if (index < 0 || index >= videoFiles.length || isVideoLoading) return;

            isVideoLoading = true;
            mainVideo.pause();

            const playRandomStart = document.getElementById('playRandomStart').checked;
            const videoFile = videoFiles[index];

            const onMetadataLoaded = () => {
              mainVideo.removeEventListener('loadedmetadata', onMetadataLoaded);
              if (startTime !== -1) {
                mainVideo.currentTime = startTime;
              } else if (playRandomStart && isFinite(mainVideo.duration)) {
                mainVideo.currentTime = Math.random() * mainVideo.duration * 0.9;
              }
              const playPromise = mainVideo.play();
              if (playPromise !== undefined) {
                playPromise.then(() => {
                  isVideoLoading = false;
                }).catch(error => {
                  if (error.name !== 'AbortError') {
                    console.error("Autoplay failed:", error);
                  }
                  isVideoLoading = false;
                });
              } else {
                isVideoLoading = false;
              }
            };

            mainVideo.addEventListener('loadedmetadata', onMetadataLoaded);
            
            // Revoke previous URL if it exists and is a blob URL
            if (mainVideo.src && mainVideo.src.startsWith('blob:')) {
              revokeTrackedObjectURL(mainVideo.src);
            }
            
            mainVideo.src = createTrackedObjectURL(videoFile);
            currentVideoIndex = index;
          };

          videoInput.addEventListener('change', async (event) => {
            videoFiles = Array.from(event.target.files).filter(file => file.type.startsWith('video/'));
            if (videoFiles.length > 0) {
              if (document.getElementById('shuffleOnLoad').checked) {
                videoFiles.sort(() => Math.random() - 0.5);
              }
              playVideoByIndex(0);
              populateRandomVideoSelector();
            } else {
              showToast("No video files found.", "warning");
            }
          });
          mainVideo.onended = () => advanceVideo(1);

          // --- Media Controls ---
          const mediaControlsOverlay = document.getElementById('mediaControlsOverlay');
          const minimizeControlsToggle = document.getElementById('minimize-controls-toggle');
          minimizeControlsToggle.addEventListener('click', () => {
            mediaControlsOverlay.classList.toggle('hidden');
            minimizeControlsToggle.innerHTML = mediaControlsOverlay.classList.contains('hidden') ? 'üîº' : 'üîΩ';
          });
          const playPauseButton = document.getElementById('playPauseButton');
          playPauseButton.addEventListener('click', () => {
            if (!mainVideo.currentSrc) {
              showToast("Please select a video folder first using the 'Atmosphere Control' panel.", "info");
              document.querySelector('[data-panel="panel-playback-settings"]').click();
              return;
            }
            mainVideo.paused ? mainVideo.play() : mainVideo.pause();
          });
          mainVideo.onplay = () => playPauseButton.innerHTML = '‚è∏Ô∏è';
          mainVideo.onpause = () => playPauseButton.innerHTML = '‚ñ∂Ô∏è';
          document.getElementById('nextButton').addEventListener('click', () => advanceVideo(1));
          document.getElementById('prevButton').addEventListener('click', () => advanceVideo(-1));
          document.getElementById('skipFwd10s').addEventListener('click', () => mainVideo.currentTime += 10);
          document.getElementById('skipBack10s').addEventListener('click', () => mainVideo.currentTime -= 10);
          const volumeSlider = document.getElementById('volumeSlider');
          volumeSlider.addEventListener('input', (e) => {
            mainVideo.muted = false;
            mainVideo.volume = e.target.value / 100;
          });
          mainVideo.onvolumechange = () => {
            volumeSlider.value = mainVideo.muted ? 0 : mainVideo.volume * 100;
          };
          const progressBar = document.getElementById('progressBar');
          mainVideo.ontimeupdate = () => {
            document.getElementById('currentTime').textContent = formatTime(mainVideo.currentTime);
            document.getElementById('durationTime').textContent = formatTime(mainVideo.duration);
            progressBar.value = (mainVideo.currentTime / mainVideo.duration) * 100 || 0;
          };
          progressBar.addEventListener('input', (e) => mainVideo.currentTime = (e.target.value / 100) * mainVideo.duration);

          // --- Random Selector Panel ---
          const randomVideoGrid = document.getElementById('random-video-grid');
          const populateRandomVideoSelector = () => {
            if (videoFiles.length === 0) return;
            randomVideoGrid.innerHTML = '';
            let indices = new Set();
            while (indices.size < 8 && indices.size < videoFiles.length) {
              indices.add(Math.floor(Math.random() * videoFiles.length));
            }
            indices.forEach(index => {
              const vid = document.createElement('video');
              vid.src = createTrackedObjectURL(videoFiles[index]);
              vid.muted = true;
              vid.loop = true;
              vid.playsInline = true;
              vid.onloadedmetadata = () => {
                if (isFinite(vid.duration)) {
                  vid.currentTime = Math.random() * vid.duration;
                }
                const playPromise = vid.play();
                if (playPromise !== undefined) {
                  playPromise.catch(() => {});
                }
              };
              vid.addEventListener('click', () => playVideoByIndex(index, vid.currentTime));
              randomVideoGrid.appendChild(vid);
            });
          };
          document.getElementById('refresh-random-grid').addEventListener('click', populateRandomVideoSelector);

          // --- Right Panel Features (Original Logic) ---
          document.getElementById('startIntervalChange').addEventListener('click', () => {
            clearAllTimers();
            const seconds = parseInt(document.getElementById('intervalSeconds').value) || 0;
            const minutes = parseInt(document.getElementById('intervalMinutes').value) || 0;
            const totalSeconds = seconds + (minutes * 60);
            if (totalSeconds > 0) {
              let countdown = totalSeconds;
              selectorToggleBtn.innerHTML = `<span style="font-size: 1.5rem; font-weight: bold;">${countdown}</span>`;
              videoChangeInterval = setInterval(() => {
                advanceVideo(1);
                countdown = totalSeconds + 1;
              }, totalSeconds * 1000);
              intervalCountdownInterval = setInterval(() => {
                countdown--;
                selectorToggleBtn.innerHTML = `<span style="font-size: 1.5rem; font-weight: bold;">${countdown}</span>`;
              }, 1000);
              currentTimers.push(videoChangeInterval, intervalCountdownInterval);
              closeAllPanels();
            }
          });
          document.getElementById('startBreathingGuideButton').addEventListener('click', () => {
            if (videoFiles.length === 0) return showToast("Please upload videos first.", "warning");
            closeAllPanels();
            clearAllTimers();
            let breaths = parseInt(document.getElementById('breaths').value);
            const changePerPhase = document.getElementById('changePerPhase').checked;
            const changePerBreath = document.getElementById('changePerBreath').checked;
            const breathingOverlay = document.getElementById('breathingOverlay');
            const overlayTimer = breathingOverlay.querySelector('.overlay-timer');
            const overlayText = breathingOverlay.querySelector('.overlay-text');
            const scoreInterval = setInterval(() => updateMainScore(200), 1000);
            currentTimers.push(scoreInterval);

            const runStage = (name, duration, nextFn, colorClass) => {
              if (breaths <= 0 && name === 'Inhale') {
                clearAllTimers();
                breathingOverlay.className = 'overlay';
                document.getElementById('completionOverlay').classList.add('visible');
                currentTimers.push(setTimeout(() => document.getElementById('completionOverlay').classList.remove('visible'), 3000));
                return;
              }
              if (changePerPhase) advanceVideo(1);
              breathingOverlay.className = `overlay visible ${colorClass}`;
              overlayText.textContent = name;
              let count = duration;
              overlayTimer.textContent = count;
              const interval = setInterval(() => {
                count--;
                overlayTimer.textContent = count;
                if (count < 0) {
                  clearInterval(interval);
                  if (name === 'Exhale') {
                    breaths--;
                    if (changePerBreath) advanceVideo(1);
                  }
                  nextFn();
                }
              }, 1000);
              currentTimers.push(interval);
            };
            const exhale = () => runStage('Exhale', parseInt(document.getElementById('exhale').value), inhale, 'overlay-exhale');
            const hold = () => runStage('Hold', parseInt(document.getElementById('hold').value), exhale, 'overlay-hold');
            const inhale = () => runStage('Inhale', parseInt(document.getElementById('inhale').value), hold, 'overlay-inhale');
            inhale();
          });
          document.getElementById('startCountdownButton').addEventListener('click', () => {
            if (videoFiles.length === 0) return showToast("Please upload videos first.", "warning");
            closeAllPanels();
            clearAllTimers();
            const countdownOverlay = document.getElementById('countdownOverlay');
            countdownOverlay.classList.add('visible');
            let seconds = parseInt(document.getElementById('countdownTimerSeconds').value);
            countdownOverlay.textContent = seconds;
            const changeInterval = parseInt(document.getElementById('countdownVideoChangeSeconds').value);
            if (changeInterval > 0) {
              videoChangeInterval = setInterval(() => advanceVideo(1), changeInterval * 1000);
              currentTimers.push(videoChangeInterval);
            }
            const interval = setInterval(() => {
              seconds--;
              countdownOverlay.textContent = seconds;
              if (seconds < 0) {
                clearAllTimers();
                document.getElementById('completionOverlay').classList.add('visible');
                currentTimers.push(setTimeout(() => document.getElementById('completionOverlay').classList.remove('visible'), 3000));
              }
            }, 1000);
            currentTimers.push(interval);
          });
          const guessEmojis = ['üçÜ', 'üçë', 'üßç'];
          const guessingInputsContainer = document.getElementById('guessing-inputs-container');
          for (let i = 1; i <= 4; i++) {
            const group = document.createElement('div');
            group.className = 'guess-input-group flex items-center gap-2 mb-2';
            group.innerHTML = `<input type="text" id="player${i}Guess" placeholder="Player ${i} Guess..."><span class="guess-emoji-cycler text-2xl cursor-pointer" data-player="${i}">${guessEmojis[0]}</span>`;
            guessingInputsContainer.appendChild(group);
            parseEmojis(group);
          }
          guessingInputsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('guess-emoji-cycler')) {
              let currentEmojiIndex = guessEmojis.indexOf(e.target.textContent);
              currentEmojiIndex = (currentEmojiIndex + 1) % guessEmojis.length;
              e.target.textContent = guessEmojis[currentEmojiIndex];
              parseEmojis(e.target);
            }
          });
          document.getElementById('startGuessGameButton').addEventListener('click', () => {
            if (videoFiles.length === 0) return showToast("Please upload videos first.", "warning");
            closeAllPanels();
            clearAllTimers();
            advanceVideo(1);
            onScreenTallyContainer.innerHTML = '';
            onScreenTallyContainer.className = '';
            guessEmojis.forEach(emoji => {
              const tallyDiv = document.createElement('div');
              tallyDiv.className = 'on-screen-tally-emoji';
              tallyDiv.setAttribute('role', 'button');
              tallyDiv.setAttribute('tabindex', '0');
              tallyDiv.innerHTML = `<span class="on-screen-tally-icon">${emoji}</span><span class="on-screen-tally-count">0</span>`;
              const incrementCount = () => {
                const countSpan = tallyDiv.querySelector('.on-screen-tally-count');
                countSpan.textContent = parseInt(countSpan.textContent, 10) + 1;
              };
              tallyDiv.addEventListener('pointerdown', (event) => {
                event.preventDefault();
                incrementCount();
              });
              tallyDiv.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                  event.preventDefault();
                  incrementCount();
                }
              });
              onScreenTallyContainer.appendChild(tallyDiv);
            });
            parseEmojis(onScreenTallyContainer);
            onScreenTallyContainer.classList.add('visible');
            let seconds = parseInt(document.getElementById('guessTimerDuration').value);
            const changeInterval = parseInt(document.getElementById('guessVideoChangeSeconds').value);
            if (changeInterval > 0) {
              videoChangeInterval = setInterval(() => advanceVideo(1), changeInterval * 1000);
              currentTimers.push(videoChangeInterval);
            }
            const countdownOverlay = document.getElementById('countdownOverlay');
            countdownOverlay.classList.add('visible');
            countdownOverlay.textContent = seconds;
            const interval = setInterval(() => {
              seconds--;
              countdownOverlay.textContent = seconds;
              if (seconds < 0) {
                clearAllTimers();
                onScreenTallyContainer.classList.remove('visible');
                document.getElementById('completionOverlay').classList.add('visible');
                currentTimers.push(setTimeout(() => document.getElementById('completionOverlay').classList.remove('visible'), 3000));
              }
            }, 1000);
            currentTimers.push(interval);
          });
          let bingoSelections = [];
          let bingoCurrentPlayer = 0;
          const setupBingoBtn = document.getElementById('setupBingoButton');
          const bingoSelectionActive = document.getElementById('bingo-selection-active');
          const generateBingoCardsBtn = document.getElementById('generateBingoCardsButton');
          setupBingoBtn.addEventListener('click', () => {
            bingoCardsOverlayContainer.innerHTML = '';
            const playerCount = parseInt(document.getElementById('playerCount').value);
            setupScores(playerCount);
            bingoSelections = Array(playerCount).fill(0).map(() => []);
            bingoCurrentPlayer = 0;
            document.getElementById('bingo-setup').classList.add('hidden');
            bingoSelectionActive.classList.remove('hidden');
            generateBingoCardsBtn.disabled = true;
            const masterList = document.getElementById('bingo-master-list');
            const turnIndicator = document.getElementById('bingo-turn-indicator');
            masterList.innerHTML = '';
            masterList.className = 'grid grid-cols-2 gap-2 max-h-96 overflow-y-auto';
            const updateTurnIndicator = () => {
              const picksLeft = 9 - bingoSelections[bingoCurrentPlayer].length;
              turnIndicator.textContent = `Player ${bingoCurrentPlayer + 1}'s Turn (${picksLeft} left)`;
              turnIndicator.style.color = playerColors[bingoCurrentPlayer];
            };
            bingoPrompts.forEach(prompt => {
              const item = document.createElement('div');
              item.className = 'bingo-item p-2 bg-gray-700 rounded cursor-pointer text-xs';
              item.textContent = prompt;
              item.dataset.owner = -1;
              item.addEventListener('click', () => {
                const currentOwner = parseInt(item.dataset.owner);
                if (bingoSelections[bingoCurrentPlayer].length < 9 || currentOwner === bingoCurrentPlayer) {
                  if (currentOwner !== -1 && currentOwner !== bingoCurrentPlayer) {
                    const oldOwnerList = bingoSelections[currentOwner];
                    const indexToRemove = oldOwnerList.indexOf(prompt);
                    if (indexToRemove > -1) oldOwnerList.splice(indexToRemove, 1);
                  }
                  if (currentOwner !== bingoCurrentPlayer) {
                    bingoSelections[bingoCurrentPlayer].push(prompt);
                    item.dataset.owner = bingoCurrentPlayer;
                    item.style.backgroundColor = playerColors[bingoCurrentPlayer];
                  } else {
                    const indexToRemove = bingoSelections[bingoCurrentPlayer].indexOf(prompt);
                    if (indexToRemove > -1) bingoSelections[bingoCurrentPlayer].splice(indexToRemove, 1);
                    item.dataset.owner = -1;
                    item.style.backgroundColor = '#333';
                  }
                }
                const allDone = bingoSelections.every(p => p.length === 9);
                generateBingoCardsBtn.disabled = !allDone;
                if (allDone) {
                  turnIndicator.textContent = "Ready! Generate Cards.";
                } else {
                  bingoCurrentPlayer = (bingoCurrentPlayer + 1) % playerCount;
                  updateTurnIndicator();
                }
              });
              masterList.appendChild(item);
            });
            updateTurnIndicator();
          });
          generateBingoCardsBtn.addEventListener('click', () => {
            closeAllPanels();
            bingoCardsOverlayContainer.innerHTML = '';
            bingoSelections.forEach((playerPrompts, i) => {
              const card = document.createElement('div');
              card.className = 'bingo-card-widget';
              card.style.top = `${15 + i * 15}px`;
              card.style.left = `${15 + i * 15}px`;
              const playerName = challengePlayers[i] ? challengePlayers[i].name : `Player ${i+1}`;
              card.innerHTML = `<div class="bingo-card-header" style="background-color:${playerColors[i]}"><span>${playerName}</span><button class="bingo-card-close-btn">&times;</button></div><div class="bingo-grid-container"></div>`;
              const gridContainer = card.querySelector('.bingo-grid-container');
              playerPrompts.forEach(prompt => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.textContent = prompt;
                cell.addEventListener('click', () => {
                  const isMarked = cell.classList.toggle('marked');
                  updateScore(i, isMarked ? 1 : -1);
                });
                gridContainer.appendChild(cell);
              });
              bingoCardsOverlayContainer.appendChild(card);
              makeDraggable(card);
            });
          });

          function makeDraggable(elmnt) {
            let pos1 = 0,
              pos2 = 0,
              pos3 = 0,
              pos4 = 0;
            const header = elmnt.querySelector('.bingo-card-header, #scoreboard-header') || elmnt;
            if (header) {
              header.onmousedown = dragMouseDown;
            }

            function dragMouseDown(e) {
              e.preventDefault();
              pos3 = e.clientX;
              pos4 = e.clientY;
              document.onmouseup = closeDragElement;
              document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
              e.preventDefault();
              pos1 = pos3 - e.clientX;
              pos2 = pos4 - e.clientY;
              pos3 = e.clientX;
              pos4 = e.clientY;
              elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
              elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
            }

            function closeDragElement() {
              document.onmouseup = null;
              document.onmousemove = null;
            }
          }
          bingoCardsOverlayContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('bingo-card-close-btn')) {
              e.target.closest('.bingo-card-widget').remove();
            }
          });
          const startTriviaBtn = document.getElementById('start-trivia-btn');
          const randomTriviaThemeBtn = document.getElementById('random-trivia-theme-btn');
          const triviaQuestionsInput = document.getElementById('trivia-questions');
          const triviaSpeedRoundInput = document.getElementById('trivia-speed-round');
          const difficultySlider = document.getElementById('trivia-difficulty-slider');
          const difficultyLabel = document.getElementById('difficulty-label');
          let triviaState = {};
          const difficultyMap = {
            1: "very easy",
            2: "easy",
            3: "beginner",
            4: "simple",
            5: "fairly well known",
            6: "medium",
            7: "hard",
            8: "very hard",
            9: "expert",
            10: "ridiculously hard for experts"
          };
          difficultySlider.addEventListener('input', () => {
            difficultyLabel.textContent = difficultyMap[difficultySlider.value];
          });
          triviaQuestionsInput.addEventListener('input', () => {
            if (parseInt(triviaQuestionsInput.value) > 0) {
              triviaSpeedRoundInput.value = 0;
              triviaSpeedRoundInput.disabled = true;
            } else {
              triviaSpeedRoundInput.disabled = false;
            }
          });
          triviaSpeedRoundInput.addEventListener('input', () => {
            if (parseInt(triviaSpeedRoundInput.value) > 0) {
              triviaQuestionsInput.value = 0;
              triviaQuestionsInput.disabled = true;
            } else {
              triviaQuestionsInput.disabled = false;
            }
          });
          randomTriviaThemeBtn.addEventListener('click', async (e) => {
            const btn = e.target;
            const themeInput = document.getElementById('trivia-theme');
            btn.disabled = true;
            themeInput.value = 'Generating...';
            const prompt = "Generate a single, fun, SFW trivia category or theme. For example: '80s Music', 'World Capitals', 'Famous Inventions'.";
            const result = await callGemini(prompt);
            if (result) {
              themeInput.value = result.replace(/"/g, '');
            } else {
              themeInput.value = 'Error! Try again.';
            }
            btn.disabled = false;
          });
          startTriviaBtn.addEventListener('click', async (e) => {
            const btn = e.target;
            btn.disabled = true;
            btn.textContent = 'Generating...';
            const theme = document.getElementById('trivia-theme').value || 'general knowledge';
            const numPlayers = parseInt(document.getElementById('trivia-players').value);
            let numQuestions = parseInt(document.getElementById('trivia-questions').value);
            const speedRoundSecs = parseInt(document.getElementById('trivia-speed-round').value);
            const difficulty = difficultyMap[difficultySlider.value];
            const progressive = document.getElementById('trivia-progressive').checked ? 'The questions should get progressively harder.' : '';
            if (speedRoundSecs > 0) numQuestions = 20;
            const prompt =
              `Create a JSON array of ${numQuestions} trivia questions on the theme of "${theme}". The difficulty should be ${difficulty}. ${progressive} Each object in the array must have three properties: "question" (string), "options" (an array of exactly 4 strings), and "correctAnswerIndex" (a number from 0 to 3 indicating the correct option).`;
            const schema = {
              type: "ARRAY",
              items: {
                type: "OBJECT",
                properties: {
                  "question": {
                    "type": "STRING"
                  },
                  "options": {
                    "type": "ARRAY",
                    "items": {
                      "type": "STRING"
                    }
                  },
                  "correctAnswerIndex": {
                    "type": "INTEGER"
                  }
                },
                required: ["question", "options", "correctAnswerIndex"]
              }
            };
            const result = await callGemini(prompt, schema);
            btn.disabled = false;
            btn.textContent = 'Start Trivia';
            if (!result) {
              showToast('Failed to generate trivia questions. Please try again.', 'error');
              return;
            }
            try {
              const questions = JSON.parse(result);
              if (!Array.isArray(questions) || questions.length === 0) throw new Error("Invalid question format");
              triviaState = {
                questions,
                numPlayers,
                speedRoundSecs,
                scores: Array(numPlayers).fill(0),
                currentPlayer: 0,
                playerQuestionIndex: Array(numPlayers).fill(0),
                timer: null
              };
              setupScores(numPlayers);
              closeAllPanels();
              startPlayerTurn(0);
            } catch (e) {
              showToast('The AI generated invalid data. Please try again.', 'error');
              console.error("Failed to parse trivia JSON:", result, e);
            }
          });

          function speak(text, voiceURI) {
            if ('speechSynthesis' in window) {
              window.speechSynthesis.cancel();
              const utterance = new SpeechSynthesisUtterance(text);
              if (voiceURI) {
                const voice = speechSynthesis.getVoices().find(v => v.voiceURI === voiceURI);
                if (voice) utterance.voice = voice;
              }
              window.speechSynthesis.speak(utterance);
            }
          }

          function startPlayerTurn(playerIndex) {
            if (playerIndex >= triviaState.numPlayers) {
              endTriviaGame();
              return;
            }
            triviaState.currentPlayer = playerIndex;
            triviaGameOverlay.innerHTML = `<div style="font-size: 3rem;">Player ${playerIndex + 1}, Get Ready!</div>`;
            triviaGameOverlay.classList.add('visible');
            setTimeout(() => {
              displayTriviaQuestion();
            }, 3000);
          }

          function displayTriviaQuestion() {
            const questionsPerPlayer = Math.ceil(triviaState.questions.length / triviaState.numPlayers);
            if (triviaState.playerQuestionIndex[triviaState.currentPlayer] >= questionsPerPlayer) {
              startPlayerTurn(triviaState.currentPlayer + 1);
              return;
            }
            const questionIndex = triviaState.currentPlayer * questionsPerPlayer + triviaState.playerQuestionIndex[triviaState.currentPlayer];
            if (questionIndex >= triviaState.questions.length) {
              endTriviaGame();
              return;
            }
            const q = triviaState.questions[questionIndex];
            speak(q.question);
            let answersHTML = q.options.map((opt, i) => `<button class="trivia-answer-btn" data-index="${i}">${opt}</button>`).join('');
            triviaGameOverlay.innerHTML = `<div id="trivia-overlay"><div id="trivia-player-indicator">Player ${triviaState.currentPlayer + 1}</div><div id="trivia-question">${q.question}</div><div id="trivia-answers">${answersHTML}</div></div>`;
            triviaGameOverlay.classList.add('visible');
          }
          triviaGameOverlay.addEventListener('click', (e) => {
            if (e.target.classList.contains('trivia-answer-btn')) {
              const questionsPerPlayer = Math.ceil(triviaState.questions.length / triviaState.numPlayers);
              const questionIndex = triviaState.currentPlayer * questionsPerPlayer + triviaState.playerQuestionIndex[triviaState.currentPlayer];
              const correctAnswer = triviaState.questions[questionIndex].correctAnswerIndex;
              const playerAnswer = parseInt(e.target.dataset.index);
              if (playerAnswer === correctAnswer) {
                updateScore(triviaState.currentPlayer, 1);
                e.target.style.backgroundColor = '#27ae60';
              } else {
                updateScore(triviaState.currentPlayer, -1);
                e.target.style.backgroundColor = '#c0392b';
                triviaGameOverlay.querySelector(`[data-index="${correctAnswer}"]`).style.backgroundColor = '#27ae60';
              }
              setTimeout(() => {
                triviaState.playerQuestionIndex[triviaState.currentPlayer]++;
                displayTriviaQuestion();
              }, 2000);
            }
          });

          function endTriviaGame() {
            clearAllTimers();
            let scoreText = '<h2>Final Scores</h2>';
            scores.forEach((score, i) => {
              scoreText += `<div>Player ${i+1}: ${score}</div>`;
            });
            triviaGameOverlay.innerHTML = `<div id="trivia-overlay">${scoreText}</div>`;
            setTimeout(() => {
              triviaGameOverlay.classList.remove('visible');
            }, 10000);
          }

          function setupScores(numPlayers) {
            scores = Array(numPlayers).fill(0);
            renderScores();
            scoreboardContainer.classList.remove('hidden');
          }

          function updateScore(playerIndex, amount) {
            if (scores[playerIndex] !== undefined) {
              scores[playerIndex] += amount;
              renderScores();
            }
          }

          function renderScores() {
            scoreboardContainer.innerHTML = `<div id="scoreboard-header"><button id="scoreboard-close-btn">&times;</button></div><div id="scores-wrapper"></div>`;
            const scoresWrapper = document.getElementById('scores-wrapper');
            scores.forEach((score, i) => {
              const widget = document.createElement('div');
              widget.className = 'score-widget';
              widget.style.backgroundColor = playerColors[i];
              widget.innerHTML =
                `<div class="score-display">${score}</div><div class="score-controls"><button class="score-plus" data-player="${i}">+</button><button class="score-minus" data-player="${i}">-</button><button class="score-hide" data-player="${i}">üëÅÔ∏è</button><button class="score-reset" data-player="${i}">üîÑ</button></div>`;
              scoresWrapper.appendChild(widget);
            });
            parseEmojis(scoreboardContainer);
            makeDraggable(scoreboardContainer);
          }
          scoreboardContainer.addEventListener('click', (e) => {
            const target = e.target;
            if (target.id === 'scoreboard-close-btn') {
              scoreboardContainer.classList.add('hidden');
              scores = [];
              return;
            }
            const playerIndex = parseInt(target.dataset.player);
            if (isNaN(playerIndex)) return;
            if (target.classList.contains('score-plus')) updateScore(playerIndex, 1);
            if (target.classList.contains('score-minus')) updateScore(playerIndex, -1);
            if (target.classList.contains('score-reset')) {
              scores[playerIndex] = 0;
              renderScores();
            }
            if (target.classList.contains('score-hide')) {
              scoreboardContainer.style.opacity = scoreboardContainer.style.opacity === '0' ? '1' : '0';
            }
          });
          const generateScriptBtn = document.getElementById('generate-script-btn');
          const generateTitleBtn = document.getElementById('generate-title-btn');
          generateTitleBtn.addEventListener('click', async (e) => {
            const btn = e.target;
            const titleInput = document.getElementById('story-maker-title');
            btn.disabled = true;
            titleInput.value = 'Generating...';
            const prompt = "Generate a short, punny, innuendo-filled, cloud-themed movie title suitable for a gay-themed trailer.";
            const result = await callGemini(prompt);
            if (result) {
              titleInput.value = result.replace(/"/g, '');
            } else {
              titleInput.value = 'Error! Try again.';
            }
            btn.disabled = false;
          });
          generateScriptBtn.addEventListener('click', async (e) => {
            const btn = e.target;
            const title = document.getElementById('story-maker-title').value || 'a generic movie';
            const numScenes = document.getElementById('story-maker-scenes').value;
            btn.disabled = true;
            btn.textContent = 'Generating...';
            const prompt =
              `Generate a JSON array for a movie trailer script about "${title}". The array should contain exactly ${numScenes} objects. Each object must have three properties: "sentence" (a punny, innuendo-filled, cloud-themed voiceover line about gay sex acts or rendezvous), "clue" (a 2-3 word summary of the sentence), and "duration" (a number between 5 and 10 representing how many seconds the clip should play). The sentences must form a cohesive, dramatic trailer arc.`;
            const schema = {
              type: "ARRAY",
              items: {
                type: "OBJECT",
                properties: {
                  "sentence": {
                    "type": "STRING"
                  },
                  "clue": {
                    "type": "STRING"
                  },
                  "duration": {
                    "type": "INTEGER"
                  }
                },
                required: ["sentence", "clue", "duration"]
              }
            };
            const result = await callGemini(prompt, schema);
            btn.disabled = false;
            btn.textContent = '‚ú® Generate Dream Script';
            if (result) {
              try {
                const script = JSON.parse(result);
                if (!Array.isArray(script)) throw new Error();
                storyMakerState.script = script;
                storyMakerState.timelineClips = Array(script.length).fill(null);
                startStoryMakerGame();
                closeAllPanels();
              } catch (e) {
                showToast('AI generated invalid data. Please try again.', 'error');
              }
            } else {
              showToast('Failed to generate script. Please add your Gemini API key (top right) and try again.', 'error');
            }
          });

          function startStoryMakerGame() {
            const storyMakerBG = document.getElementById('story-maker-bg');
            storyMakerContainer.style.display = 'flex';
            storyMakerBG.style.display = 'block';
            mainVideo.pause();
            mediaControlsOverlay.classList.add('hidden');
            minimizeControlsToggle.innerHTML = 'üîº';
            storyMakerState.currentScene = 0;
            loadStoryMakerScene(0);
          }

          function loadStoryMakerScene(sceneIndex) {
            clearAllTimers();
            if (sceneIndex >= storyMakerState.script.length) {
              finalizeMovie();
              return;
            }
            const scene = storyMakerState.script[sceneIndex];
            storyMakerContainer.innerHTML =
              `<div id="story-maker-grid"><div id="story-maker-left-panel"><div class="story-maker-dropzone">DROP CLIP HERE</div><div id="story-maker-clue">${scene.clue}</div><div id="story-maker-effects"><button class="effect-btn" data-effect="bw">B&W</button><button class="effect-btn" data-effect="sepia">Sepia</button><button class="effect-btn" data-effect="invert">Invert</button><button class="effect-btn" data-effect="strobe">Strobe</button></div></div><div id="story-maker-clip-area"><div id="scene-timer-display">30</div><div id="story-maker-clip-grid"></div><div class="flex gap-4 mt-4"><button id="shuffle-clips-btn" class="panel-toggle-button" style="width: auto; padding: 0 1rem;">Shuffle</button><button id="finish-scene-btn" class="panel-toggle-button" style="width: auto; padding: 0 1rem;">Finish Scene</button></div></div></div>`;
            populateStoryMakerClipGrid();
            let sceneTimeLeft = 30;
            const sceneTimer = setInterval(() => {
              sceneTimeLeft--;
              const timerDisplay = document.getElementById('scene-timer-display');
              if (timerDisplay) timerDisplay.textContent = sceneTimeLeft;
              if (sceneTimeLeft <= 0) {
                finishScene();
              }
            }, 1000);
            currentTimers.push(sceneTimer);
            document.getElementById('finish-scene-btn').onclick = () => {
              finishScene();
            };
            document.getElementById('shuffle-clips-btn').onclick = populateStoryMakerClipGrid;
          }

          function finishScene() {
            clearAllTimers();
            storyMakerState.currentScene++;
            loadStoryMakerScene(storyMakerState.currentScene);
          }

          function populateStoryMakerClipGrid() {
            const grid = document.getElementById('story-maker-clip-grid');
            if (!grid) return;
            grid.innerHTML = '';
            let indices = new Set();
            while (indices.size < 4 && indices.size < videoFiles.length) {
              indices.add(Math.floor(Math.random() * videoFiles.length));
            }
            indices.forEach(index => {
              const cell = document.createElement('div');
              cell.className = 'story-maker-clip-cell';
              const vid = document.createElement('video');
              vid.src = createTrackedObjectURL(videoFiles[index]);
              vid.muted = true;
              vid.loop = true;
              vid.playsInline = true;
              vid.draggable = true;
              vid.dataset.videoIndex = index;
              vid.onloadedmetadata = () => {
                vid.currentTime = Math.random() * vid.duration;
                vid.dataset.startTime = vid.currentTime;
                vid.play().catch(() => {});
              };
              vid.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', JSON.stringify({
                  videoIndex: vid.dataset.videoIndex,
                  startTime: vid.dataset.startTime
                }));
              });
              cell.innerHTML = `<button class="clip-arrow clip-arrow-left">‚óÄÔ∏è</button><button class="clip-arrow clip-arrow-right">‚ñ∂Ô∏è</button>`;
              cell.prepend(vid);
              grid.appendChild(cell);
            });
          }
          storyMakerContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('clip-arrow')) {
              const cell = e.target.closest('.story-maker-clip-cell');
              const video = cell.querySelector('video');
              const direction = e.target.classList.contains('clip-arrow-left') ? -10 : 10;
              video.currentTime += direction;
              video.dataset.startTime = video.currentTime;
            } else if (e.target.classList.contains('effect-btn')) {
              const effect = e.target.dataset.effect;
              const currentClip = storyMakerState.timelineClips[storyMakerState.currentScene];
              const dropzoneVideo = document.querySelector('.story-maker-dropzone video');
              if (currentClip && dropzoneVideo) {
                if (currentClip.effect === effect) {
                  currentClip.effect = 'none';
                  e.target.classList.remove('active');
                } else {
                  currentClip.effect = effect;
                  document.querySelectorAll('#story-maker-effects .effect-btn').forEach(btn => btn.classList.remove('active'));
                  e.target.classList.add('active');
                }
                dropzoneVideo.className = '';
                if (currentClip.effect !== 'none') {
                  dropzoneVideo.classList.add(`video-${currentClip.effect}`);
                }
              }
            }
          });
          storyMakerContainer.addEventListener('dragover', (e) => {
            if (e.target.classList.contains('story-maker-dropzone')) {
              e.preventDefault();
            }
          });
          storyMakerContainer.addEventListener('drop', (e) => {
            const dropzone = e.target.closest('.story-maker-dropzone');
            if (dropzone) {
              e.preventDefault();
              const data = JSON.parse(e.dataTransfer.getData('text/plain'));
              storyMakerState.timelineClips[storyMakerState.currentScene] = {
                videoIndex: data.videoIndex,
                startTime: data.startTime,
                effect: 'none'
              };
              const vid = document.createElement('video');
              vid.src = createTrackedObjectURL(videoFiles[data.videoIndex]);
              vid.muted = true;
              vid.loop = true;
              vid.playsInline = true;
              vid.onloadedmetadata = () => {
                vid.currentTime = data.startTime;
                vid.play().catch(() => {});
              };
              dropzone.innerHTML = '';
              dropzone.appendChild(vid);
              document.querySelectorAll('#story-maker-effects .effect-btn').forEach(btn => btn.classList.remove('active'));
            }
          });

          function finalizeMovie() {
            storyMakerContainer.style.display = 'none';
            document.getElementById('story-maker-bg').style.display = 'none';
            const completionOverlay = document.getElementById('completionOverlay');
            completionOverlay.innerHTML = 'Preparing your video...';
            completionOverlay.classList.add('visible');
            setTimeout(() => {
              completionOverlay.innerHTML = '<button id="final-play-btn" style="font-size: 5rem; background: none; border: none; color: white; cursor: pointer;">‚ñ∂Ô∏è</button>';
            }, 2000);
          }
          document.addEventListener('click', e => {
            if (e.target && e.target.id === 'final-play-btn') {
              playFinalMovie();
            } else if (e.target && e.target.id === 'replay-movie-btn') {
              playFinalMovie();
            }
          });
          async function playFinalMovie() {
            document.getElementById('completionOverlay').classList.remove('visible');
            const movieOverlay = document.getElementById('movie-playback-overlay');
            movieOverlay.innerHTML = '';
            movieOverlay.classList.add('visible');
            for (let i = 0; i < storyMakerState.timelineClips.length; i++) {
              const clip = storyMakerState.timelineClips[i];
              if (!clip) continue;
              const line = storyMakerState.script[i];
              const sentenceDisplay = document.createElement('div');
              sentenceDisplay.className = 'movie-sentence-display';
              sentenceDisplay.textContent = line.sentence;
              sentenceDisplay.style.fontFamily = document.getElementById('story-maker-font').value;
              movieOverlay.appendChild(sentenceDisplay);
              mainVideo.className = '';
              mainVideo.playbackRate = 1;
              if (clip.effect !== 'none') {
                mainVideo.classList.add(`video-${clip.effect}`);
              }
              speak(line.sentence, document.getElementById('story-maker-voice').value);
              setTimeout(() => {
                sentenceDisplay.style.opacity = 1;
              }, 100);
              await new Promise(resolve => {
                playVideoByIndex(clip.videoIndex, clip.startTime);
                const onCanPlay = () => {
                  mainVideo.removeEventListener('canplay', onCanPlay);
                  setTimeout(() => {
                    sentenceDisplay.style.opacity = 0;
                    setTimeout(() => sentenceDisplay.remove(), 500);
                    resolve();
                  }, line.duration * 1000);
                };
                mainVideo.addEventListener('canplay', onCanPlay, {
                  once: true
                });
              });
            }
            movieOverlay.classList.remove('visible');
            mainVideo.pause();
            mainVideo.className = '';
            mainVideo.playbackRate = 1;
            const completionOverlay = document.getElementById('completionOverlay');
            completionOverlay.innerHTML = '<button id="replay-movie-btn" style="font-size: 5rem; background: none; border: none; color: white; cursor: pointer;">üîÑ</button>';
            parseEmojis(completionOverlay);
            completionOverlay.classList.add('visible');
          }

          // --- Challenge Logic ---
          function initChallengeGrid() {
            challengeGrid.innerHTML = '';
            resetChallengeGameState();
            
            challenges.forEach((challenge, index) => {
              const square = document.createElement('div');
              square.className = 'challenge-square';
              square.dataset.challengeIndex = index;
              square.dataset.owner = '';
              
              // Use image from shuffle-bag - ensures all 34 images are used
              const imageNum = gridImages[index];
              square.innerHTML = `
                    <div class="w-full h-full flex items-center justify-center" style="background-image: url('images/${imageNum}.png'); background-size: cover; background-position: center;"></div>
                    <div class="status-overlay"></div>
                `;
              
              square.addEventListener('click', () => {
                if (!square.classList.contains('completed') && !square.classList.contains('failed')) {
                  openTask(index);
                }
              });
              challengeGrid.appendChild(square);
            });
          }

          async function openTask(index) {
            let challenge = challenges[index];
            activeTaskElement = document.querySelector(`.challenge-square[data-challenge-index='${index}']`);
            isTaskCompleted = false;
            stopScoreDecay();
            taskModalOverlay.style.pointerEvents = 'all'; // Reset pointer events

            taskModalBody.innerHTML = `<div class="text-center p-8"><h3 class="text-2xl mb-2">Preparing Challenge...</h3><p class="text-gray-400">Please wait a moment.</p></div>`;
            taskModalOverlay.classList.add('visible');

            // Check if this tile was previously failed and has a last game type
            const lastGameType = tileLastGameType[index];
            
            if (Array.isArray(challenge)) {
              // If tile failed previously, filter out the last game type
              let availableChallenges = challenge;
              if (lastGameType) {
                availableChallenges = challenge.filter(c => c.type !== lastGameType);
                // If all options were filtered, reset and use original
                if (availableChallenges.length === 0) {
                  availableChallenges = challenge;
                }
              }
              
              taskModalTitle.textContent = "Choose Your Challenge!";
              taskModalBody.innerHTML = `<div class="task-option-grid">${availableChallenges.map(c => `<button class="task-option-btn" data-challenge-type="${c.type}">${c.icon} ${c.name}</button>`).join('')}</div>`;
              taskModalBody.querySelectorAll('.task-option-btn').forEach(btn => {
                btn.onclick = () => {
                  tileLastGameType[index] = btn.dataset.challengeType;
                  startConcreteTask(btn.dataset.challengeType);
                };
              });
            } else {
              // Single challenge type - if failed previously, try to pick different one from challengeTypes
              if (lastGameType && lastGameType === challenge.type) {
                // Pick a different challenge type
                const availableTypes = challengeTypes.filter(c => c.type !== lastGameType);
                if (availableTypes.length > 0) {
                  challenge = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                }
              }
              
              tileLastGameType[index] = challenge.type;
              startConcreteTask(challenge.type);
            }
          }

          function startConcreteTask(type, options = {}) {
            // Check if challenge requires Gemini AI and key is not available
            if (AI_REQUIRED_CHALLENGES.has(type) && (!geminiApiKey || !geminiApiKey.trim())) {
              taskModalTitle.textContent = "AI Key Required";
              taskModalBody.innerHTML = `<p style="color: #fbbf24; text-align: center; font-size: 1.1rem;">Add your Gemini API key (top right) to unlock this AI-powered challenge.</p>`;
              return;
            }
            
            taskModalContent.style.backgroundColor = challengeUIColors[type] || 'rgba(31, 31, 31, 0.5)';
            switch (type) {
              case 'trivia':
                setupTriviaTask(options.category);
                break;
              case 'matchPairs':
                setupMatchPairsTask();
                break;
              case 'blowback':
                setupBlowbackTask();
                break;

              case 'bingo':
                setupBingoBuilderTask();
                break;
              case 'aiChallenge':
                setupAiChallengeTask();
                break;

              case 'audioAnagram':
                setupAudioAnagramTask();
                break;
              case 'reflexTest':
                setupReflexTestTask();
                break;
              case 'pressureFront':
                setupPressureFrontTask();
                break;
              case 'miniBingo':
                setupMiniBingoTask();
                break;

              case 'weatherGamble':
                setupWeatherGambleTask();
                break;
              
              // NEW MINI GAMES
              case 'videoClipDetective':
                setupVideoClipDetectiveTask();
                break;
              case 'clipOrderMemory':
                setupClipOrderMemoryTask();
                break;
              case 'avatarSequence':
                setupAvatarSequenceTask();
                break;
              case 'filmTitleScrambler':
                setupFilmTitleScramblerTask();
                break;
              case 'higherLowerViews':
                setupHigherLowerViewsTask();
                break;
              case 'iconClickHunt':
                setupIconClickHuntTask();
                break;
              case 'triviaSpeedQuiz':
                setupTriviaSpeedQuizTask();
                break;
              case 'paintSplatter':
                setupPaintSplatterTask();
                break;
              case 'timestampMatch':
                setupTimestampMatchTask();
                break;
              case 'videoQuarterPuzzle':
                setupVideoQuarterPuzzleTask();
                break;
              case 'creativeChallenge':
                setupCreativeChallengeTask();
                break;
              case 'splashClick':
                setupSplashClickTask();
                break;
            }
          }

          function closeTaskModal() {
            if (!isTaskCompleted && activeTaskElement) {
              markTaskFailed();
            }
            
            // Clear all timers and intervals
            clearAllTimers();
            if (modalTimer) {
              clearInterval(modalTimer);
              modalTimer = null;
            }
            
            // Pause and cleanup any video elements in the modal
            const modalVideos = taskModalBody.querySelectorAll('video');
            modalVideos.forEach(video => {
              video.pause();
              if (video.src && video.src.startsWith('blob:')) {
                revokeTrackedObjectURL(video.src);
              }
              video.src = '';
            });
            
            // Remove any game overlays created by minigames
            const gameOverlays = document.querySelectorAll('#pf-game-overlay, #splash-click-overlay, #icon-hunt-overlay');
            gameOverlays.forEach(overlay => overlay.remove());
            
            // Revoke all tracked ObjectURLs
            revokeAllTrackedObjectURLs();
            
            // Clear modal content and reset state
            taskModalOverlay.classList.remove('visible');
            taskModalBody.innerHTML = '';
            taskModalOverlay.style.pointerEvents = 'all';
            activeTaskElement = null;
            isTaskCompleted = false;
            startScoreDecay();
          }

          function markTaskComplete() {
            isTaskCompleted = true;
            if (activeTaskElement) {
              const ownerIndex = currentChallengePlayerIndex;
              activeTaskElement.dataset.owner = String(ownerIndex);
              activeTaskElement.classList.add('completed');
              const overlay = activeTaskElement.querySelector('.status-overlay');
              if (overlay) {
                overlay.textContent = challengePlayers[ownerIndex].badge;
              }
              if (typeof challengeScores[ownerIndex] === 'number') {
                challengeScores[ownerIndex] += 1;
                renderChallengeHud();
              }
              
              // Check for horizontal line bonus (5 columns = 5 tiles per row)
              const challengeIndex = parseInt(activeTaskElement.dataset.challengeIndex);
              const rowIndex = Math.floor(challengeIndex / 5);
              const rowStart = rowIndex * 5;
              const rowEnd = rowStart + 5;
              
              // Check if all tiles in this row are owned by the current player
              let allOwnedByPlayer = true;
              for (let i = rowStart; i < rowEnd && i < challenges.length; i++) {
                const tile = document.querySelector(`.challenge-square[data-challenge-index='${i}']`);
                if (!tile || tile.dataset.owner !== String(ownerIndex)) {
                  allOwnedByPlayer = false;
                  break;
                }
              }
              
              // Award horizontal line bonus
              if (allOwnedByPlayer) {
                const bonusPoints = 2000;
                updateMainScore(bonusPoints);
                
                // Visual feedback
                for (let i = rowStart; i < rowEnd && i < challenges.length; i++) {
                  const tile = document.querySelector(`.challenge-square[data-challenge-index='${i}']`);
                  if (tile) {
                    tile.style.boxShadow = '0 0 30px rgba(255, 215, 0, 0.8)';
                    tile.style.borderColor = '#ffd700';
                    tile.style.borderWidth = '3px';
                    tile.style.borderStyle = 'solid';
                  }
                }
                
                // Show bonus notification
                const bonusNotif = document.createElement('div');
                bonusNotif.style.cssText = `
                  position: fixed;
                  top: 50%;
                  left: 50%;
                  transform: translate(-50%, -50%);
                  background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
                  color: #000;
                  padding: 2rem 3rem;
                  border-radius: 20px;
                  font-size: 2rem;
                  font-weight: bold;
                  z-index: 9999;
                  box-shadow: 0 10px 40px rgba(255, 215, 0, 0.5);
                  animation: bonusPulse 0.5s ease-in-out;
                `;
                bonusNotif.textContent = `üéâ HORIZONTAL LINE! +${bonusPoints} üéâ`;
                document.body.appendChild(bonusNotif);
                
                setTimeout(() => bonusNotif.remove(), 2000);
              }
            }
            scoreMultiplier = parseFloat((scoreMultiplier + 0.25).toFixed(2));
            mainScoreMultiplier.textContent = scoreMultiplier.toFixed(2);
            const completionSound = new Tone.Synth().toDestination();
            completionSound.triggerAttackRelease("C5", "8n");
            advanceChallengeTurn();
            setTimeout(closeTaskModal, 500);
          }

          function markTaskFailed() {
            if (activeTaskElement) {
              activeTaskElement.classList.add('failed');
              activeTaskElement.dataset.owner = '';
              const overlay = activeTaskElement.querySelector('.status-overlay');
              if (overlay) {
                overlay.textContent = '‚úñ';
              }
              const originalIndex = activeTaskElement.dataset.challengeIndex;
              setTimeout(() => {
                const currentSquare = document.querySelector(`.challenge-square[data-challenge-index='${originalIndex}']`);
                if (currentSquare) {
                  currentSquare.classList.remove('failed');
                  currentSquare.dataset.owner = '';
                  const statusOverlay = currentSquare.querySelector('.status-overlay');
                  if (statusOverlay) {
                    statusOverlay.textContent = '';
                  }
                }
              }, 60000); // 1 minute
            }
            const failSound = new Tone.Synth().toDestination();
            failSound.triggerAttackRelease("C3", "8n");
            advanceChallengeTurn();
          }

          taskModalCloseBtn.addEventListener('pointerdown', closeTaskModal);
          
          // Add keyboard shortcut to close task modal (Escape key)
          document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && taskModalOverlay.classList.contains('visible')) {
              closeTaskModal();
            }
          });

          // --- Win/Loss Screen ---
          function showWinLossScreen(correctAnswers, totalQuestions, onComplete) {
            const scorePercent = Math.round((correctAnswers / totalQuestions) * 100);
            const isWin = scorePercent >= 60; // 60% or higher is a win
            
            const winLossHTML = `
              <div style="text-align: center; padding: 2rem;">
                <h2 style="font-size: 3rem; margin-bottom: 1rem;">${isWin ? 'üéâ Victory!' : 'üíî Try Again!'}</h2>
                <div style="font-size: 2rem; margin-bottom: 1rem; color: ${isWin ? '#27ae60' : '#e74c3c'};">
                  ${isWin ? 'WIN' : 'LOSS'}
                </div>
                <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">
                  Score: ${correctAnswers} / ${totalQuestions}
                </div>
                <div style="font-size: 1.2rem; margin-bottom: 2rem; color: #95a5a6;">
                  ${scorePercent}% Correct
                </div>
                <button id="continue-btn" class="modal-action-btn">Continue</button>
              </div>
            `;
            
            taskModalBody.innerHTML = winLossHTML;
            document.getElementById('continue-btn').onclick = () => {
              if (onComplete) onComplete();
            };
          }

          // --- Task Setup Functions ---
          async function setupTriviaTask(predefinedCategory = null) {
            taskModalTitle.textContent = "Trivia Challenge";
            const categoryName = predefinedCategory || challengeCategories[Math.floor(Math.random() * challengeCategories.length)][Math.floor(Math.random() * challengeCategories[0].length)];

            taskModalBody.innerHTML = `<h3>Loading questions...</h3><p>Please wait...</p>`;
            
            const questions = await fetchTriviaQuestions(5, null, 'medium');

            if (!questions) {
              taskModalBody.innerHTML = `<p class="text-red-500">Failed to load trivia questions. Please try again.</p>`;
              return;
            }

            let correctAnswers = 0;
            let totalQuestions = 5;

            taskModalBody.innerHTML = `
              <h3>Trivia Challenge!</h3>
              <p>Category: General Knowledge</p>
              <p style="color: #10b981; margin-top: 0.5rem;">Answer 5 questions. Get at least 3 correct to win!</p>
              <button id="start-challenge-btn" class="modal-action-btn">Start Challenge</button>
            `;
            
            document.getElementById('start-challenge-btn').onclick = () => {
              let currentQ = 0;

              function renderQuestion() {
                if (currentQ >= questions.length) {
                  // Check if player got at least 3 correct
                  const passed = correctAnswers >= 3;
                  taskModalBody.innerHTML = `
                    <h2>${passed ? 'üéâ You Passed!' : '‚ùå Not Enough Correct'}</h2>
                    <p style="font-size: 1.5rem; margin: 1rem 0;">Score: ${correctAnswers}/${totalQuestions}</p>
                    <p style="font-size: 1.2rem;">${passed ? 'You got at least 3 correct!' : 'You needed 3 correct answers.'}</p>
                    <button id="finish-trivia-btn" class="modal-action-btn mt-4">${passed ? 'Claim Square' : 'Continue'}</button>
                  `;
                  document.getElementById('finish-trivia-btn').onclick = () => {
                    if (passed) {
                      updateMainScore(1500);
                      markTaskComplete();
                    } else {
                      closeTaskModal();
                    }
                  };
                  return;
                }
                const q = questions[currentQ];
                taskModalBody.innerHTML =
                  `<p class="text-xl mb-4">(${currentQ + 1}/5) ${q.question}</p><div class="task-option-grid">${q.options.map((opt, i) => `<button class="task-option-btn" data-index="${i}">${opt}</button>`).join('')}</div>`;
                document.querySelectorAll('.task-option-btn').forEach(btn => btn.addEventListener('pointerdown', handleAnswer));
              }

              function handleAnswer(e) {
                const selectedIndex = parseInt(e.target.dataset.index);
                const correctIndex = questions[currentQ].correctAnswerIndex;
                if (selectedIndex === correctIndex) {
                  correctAnswers++;
                }
                document.querySelectorAll('.task-option-btn').forEach((btn, i) => {
                  btn.disabled = true;
                  if (i === correctIndex) btn.style.backgroundColor = '#27ae60';
                  else if (i === selectedIndex) btn.style.backgroundColor = '#c0392b';
                });
                setTimeout(() => {
                  currentQ++;
                  renderQuestion();
                }, 1500);
              }
              renderQuestion();
            };
          }

          function setupMatchPairsTask() {
            taskModalTitle.textContent = "Match the Pairs";
            const configs = [{
                size: 16,
                time: 50,
                gridClass: 'grid-cols-4',
                emojiSize: '2rem'
              },
              {
                size: 20,
                time: 70,
                gridClass: 'grid-cols-5',
                emojiSize: '1.5rem'
              }, // <-- FIX: Added missing comma here
              {
                size: 24,
                time: 90,
                gridClass: 'grid-cols-5',
                emojiSize: '1.5rem'
              }
            ];
            const config = configs[Math.floor(Math.random() * configs.length)];

            taskModalBody.innerHTML = `<h3>Ready to Match?</h3><p>Find all ${config.size / 2} pairs before time runs out.</p><button id="start-challenge-btn" class="modal-action-btn">Start Matching</button>`;
            document.getElementById('start-challenge-btn').onclick = () => {
              // FIX: Cleaned up emoji list
              const baseEmojis = ['üçÜ', 'üçë', 'üí¶', 'üëÑ', 'üëÖ', 'üí™', '‚õìÔ∏è', 'üî•', 'üòà', 'ü¶Ñ', 'üê∑', 'üí®', 'üöÄ', 'ü´ÉüèΩ'];
              const gameEmojis = [...baseEmojis.slice(0, config.size / 2), ...baseEmojis.slice(0, config.size / 2)].sort(() => 0.5 - Math.random());
              let flipped = [];
              let matchedCount = 0;
              let canClick = true;
              let timeLeft = config.time;
              taskModalBody.innerHTML =
                `<div class="flex justify-between items-center mb-4"><h3 id="pairs-timer" class="text-2xl font-bold">Time: ${timeLeft}</h3></div><div class="emoji-grid ${config.gridClass}">${gameEmojis.map((emoji, i) => `<div class="emoji-cell" data-index="${i}" style="font-size: ${config.emojiSize};"><div class="emoji-content">${emoji}</div></div>`).join('')}</div>`;
              modalTimer = setInterval(() => {
                timeLeft--;
                const timerEl = document.getElementById('pairs-timer');
                if (timerEl) timerEl.textContent = `Time: ${timeLeft}`;
                if (timeLeft <= 0) {
                  clearInterval(modalTimer);
                  updateMainScore(-1000);
                  showToast("Time's up!", "warning");
                  closeTaskModal();
                }
              }, 1000);
              document.querySelectorAll('.emoji-cell').forEach(cell => {
                cell.addEventListener('pointerdown', () => {
                  if (!canClick || cell.classList.contains('flipped') || cell.classList.contains('matched') || flipped.length >= 2) return;
                  cell.classList.add('flipped');
                  flipped.push(cell);
                  if (flipped.length === 2) {
                    canClick = false;
                    const [first, second] = flipped;
                    if (gameEmojis[first.dataset.index] === gameEmojis[second.dataset.index]) {
                      first.classList.add('matched');
                      second.classList.add('matched');
                      matchedCount += 2;
                      flipped = [];
                      canClick = true;
                      updateMainScore(500);
                      if (matchedCount === gameEmojis.length) {
                        clearInterval(modalTimer);
                        updateMainScore(timeLeft * 100);
                        markTaskComplete();
                      }
                    } else {
                      setTimeout(() => {
                        first.classList.remove('flipped');
                        second.classList.remove('flipped');
                        flipped = [];
                        canClick = true;
                      }, 1000);
                    }
                  }
                };
              });
            };
          }

          function setupBlowbackTask() {
            taskModalTitle.textContent = "Blowback!";
            const inhaleTime = Math.floor(Math.random() * 3) + 2;
            const holdTime = Math.floor(Math.random() * 3) + 2;
            const exhaleTime = Math.floor(Math.random() * 6) + 5;
            const breathCount = Math.floor(Math.random() * 6) + 5;

            document.getElementById('inhale').value = inhaleTime;
            document.getElementById('hold').value = holdTime;
            document.getElementById('exhale').value = exhaleTime;
            document.getElementById('breaths').value = breathCount;

            taskModalBody.innerHTML =
              `<h3>Ready to Breathe?</h3><p class="my-4">Inhale for ${inhaleTime}s, Hold for ${holdTime}s, Exhale for ${exhaleTime}s. Repeat ${breathCount} times.</p><button id="start-challenge-btn" class="modal-action-btn">Start Breathing</button>`;
            document.getElementById('start-challenge-btn').onclick = () => {
              isTaskCompleted = true; // Mark as completed since it runs in the background
              markTaskComplete();
              document.getElementById('startBreathingGuideButton').click();
            };
          }

          async function setupMemoryGameTask() {
            taskModalTitle.textContent = "Memory Test";
            if (videoFiles.length < 11) {
              taskModalBody.innerHTML = `<p class="text-red-500">You need to upload at least 11 videos to play this game.</p>`;
              return;
            }
            const shuffledIndices = [...videoFiles.keys()].sort(() => 0.5 - Math.random());
            const clipIndices = shuffledIndices.slice(0, 11);
            const hiddenClipIndex = clipIndices[10];
            let clipData = [];
            for (const index of clipIndices) {
              const vidFile = videoFiles[index];
              const tempVid = document.createElement('video');
              const url = createTrackedObjectURL(vidFile);
              await new Promise(resolve => {
                tempVid.onloadedmetadata = () => {
                  const startTime = Math.random() * (tempVid.duration > 3 ? tempVid.duration - 3 : 0);
                  clipData.push({
                    index,
                    url,
                    startTime
                  });
                  resolve();
                };
                tempVid.src = url;
              });
            }
            taskModalBody.innerHTML = `<h3>Ready to Watch?</h3><p>You will be shown 10 short clips. Pay attention!</p><button id="start-challenge-btn" class="modal-action-btn">Start Clips</button>`;
            document.getElementById('start-challenge-btn').onclick = async () => {
              taskModalBody.innerHTML = `<div id="memory-video-player-container"><video id="memory-player" muted playsinline></video></div>`;
              const memoryPlayer = document.getElementById('memory-player');
              const clipsToPlay = clipIndices.slice(0, 10);
              for (let i = 0; i < clipsToPlay.length; i++) {
                const data = clipData.find(c => c.index === clipsToPlay[i]);
                taskModalTitle.textContent = `Playing Clip ${i + 1} / 10`;
                memoryPlayer.src = data.url;
                memoryPlayer.currentTime = data.startTime;
                await memoryPlayer.play();
                await new Promise(resolve => setTimeout(resolve, 3000));
                memoryPlayer.pause();
              }
              taskModalTitle.textContent = "Which clip was NOT shown?";
              clipData.sort(() => 0.5 - Math.random());
              taskModalBody.innerHTML = `<div class="memory-clip-grid"></div>`;
              const grid = taskModalBody.querySelector('.memory-clip-grid');
              for (const data of clipData) {
                const thumbDiv = document.createElement('div');
                thumbDiv.className = 'memory-clip-thumbnail';
                thumbDiv.dataset.index = data.index;
                thumbDiv.innerHTML = `<video src="${data.url}#t=${data.startTime+1}" preload="metadata"></video>`;
                thumbDiv.addEventListener('pointerdown', () => {
                  document.querySelectorAll('.memory-clip-thumbnail').forEach(t => t.classList.add('disabled'));
                  if (parseInt(thumbDiv.dataset.index) === hiddenClipIndex) {
                    thumbDiv.style.outline = "4px solid #27ae60";
                    updateMainScore(2500);
                    setTimeout(markTaskComplete, 1000);
                  } else {
                    thumbDiv.style.outline = "4px solid #c0392b";
                    document.querySelector(`.memory-clip-thumbnail[data-index='${hiddenClipIndex}']`).style.outline = "4px solid #27ae60";
                    updateMainScore(-1000);
                    setTimeout(closeTaskModal, 2000);
                  }
                };
                grid.appendChild(thumbDiv);
              }
            };
          }

          function setupBingoBuilderTask() {
            taskModalTitle.textContent = "Build a 3x2 Bingo Card";
            taskModalBody.innerHTML = `<h3>Ready to Build?</h3><p>Create your custom 3x2 bingo card.</p><button id="start-challenge-btn" class="modal-action-btn">Start Building</button>`;
            document.getElementById('start-challenge-btn').onclick = () => {
              let selectedPrompts = [];
              const masterList = bingoPrompts.sort(() => 0.5 - Math.random());
              taskModalBody.innerHTML =
                `<p>Select 6 prompts from the list below:</p><div id="bingo-builder-master-list">${masterList.map(p => `<div class="bingo-item">${p}</div>`).join('')}</div><h3>Your Card Preview (<span id="bingo-pick-count">0</span>/6)</h3><div id="my-bingo-card-preview">${Array(6).fill('<div class="cell"></div>').join('')}</div><button id="confirm-bingo-card" class="modal-action-btn mt-4" disabled>Create Card</button>`;
              const updatePreview = () => {
                const cells = document.querySelectorAll('#my-bingo-card-preview .cell');
                cells.forEach((cell, i) => {
                  cell.textContent = selectedPrompts[i] || '';
                });
                document.getElementById('bingo-pick-count').textContent = selectedPrompts.length;
                document.getElementById('confirm-bingo-card').disabled = selectedPrompts.length !== 6;
              };
              document.querySelectorAll('#bingo-builder-master-list .bingo-item').forEach(item => {
                item.addEventListener('pointerdown', () => {
                  const prompt = item.textContent;
                  if (item.classList.contains('selected')) {
                    item.classList.remove('selected');
                    selectedPrompts = selectedPrompts.filter(p => p !== prompt);
                  } else if (selectedPrompts.length < 6) {
                    item.classList.add('selected');
                    selectedPrompts.push(prompt);
                  }
                  updatePreview();
                };
              });
              document.getElementById('confirm-bingo-card').addEventListener('pointerdown', () => {
                createBingoCardWidget(selectedPrompts, activeTaskElement);
                closeTaskModal();
              };
              updatePreview();
            };
          }

          function createBingoCardWidget(prompts, originalTaskElement) {
            const card = document.createElement('div');
            card.className = 'bingo-card-widget';
            const cardId = `bingo-card-${Date.now()}`;
            card.id = cardId;
            card.style.top = `${Math.random() * 50 + 20}vh`;
            card.style.left = `${Math.random() * 50 + 20}vw`;

            const currentPlayer = challengePlayers[currentChallengePlayerIndex];
            const playerName = currentPlayer ? currentPlayer.name : 'Bingo Card';
            card.innerHTML = `<div class="bingo-card-header"><span>${playerName}</span><button class="bingo-card-close-btn">&times;</button></div><div class="bingo-grid-container"></div>`;
            const gridContainer = card.querySelector('.bingo-grid-container');
            prompts.forEach(prompt => {
              const cell = document.createElement('div');
              cell.className = 'cell';
              cell.textContent = prompt;
              cell.addEventListener('click', () => {
                cell.classList.toggle('marked');
                const allMarked = [...gridContainer.querySelectorAll('.cell')].every(c => c.classList.contains('marked'));
                if (allMarked) {
                  card.remove();
                  activeTaskElement = originalTaskElement; // Re-assign active element
                  updateMainScore(2000);
                  markTaskComplete();
                }
              });
              gridContainer.appendChild(cell);
            });
            bingoCardsOverlayContainer.appendChild(card);
            makeDraggable(card);
            card.querySelector('.bingo-card-close-btn').onclick = () => card.remove();
          }

          async function setupAiChallengeTask() {
            taskModalTitle.textContent = "AI Challenge";
            const prompt = `Generate a funny, wacky, or provocative, potentially NSFW, cloud-themed creative challenge that requires a witty text response. For example: "Write a Grindr bio for a lonely rain cloud."`;
            const result = await callGemini(prompt);
            if (!result) {
              taskModalBody.innerHTML = `<p style="color: #e74c3c; text-align: center;">Failed to generate AI challenge. Please check your API key and try again.</p>`;
              return;
            }
            taskModalBody.innerHTML = `<h3>Ready for a Dare?</h3><p class="italic my-2">"${result.replace(/"/g, '')}"</p><button id="start-challenge-btn" class="modal-action-btn">Accept Challenge</button>`;
            document.getElementById('start-challenge-btn').onclick = () => {
              taskModalBody.innerHTML =
                `<p class="text-xl mb-4 italic">"${result.replace(/"/g, '')}"</p><textarea id="ai-challenge-response" rows="3" class="w-full task-input-field" placeholder="Type your witty response..."></textarea><button id="submit-ai-challenge" class="modal-action-btn mt-4">I Did It!</button>`;
              document.getElementById('submit-ai-challenge').onclick = () => {
                if (document.getElementById('ai-challenge-response').value.trim().length > 0) {
                  updateMainScore(1500);
                  markTaskComplete();
                } else {
                  showToast("You have to write something!", "warning");
                }
              };
              document.getElementById('ai-challenge-response').focus();
            };
          }

          async function setupClipSequencerTask() {
            taskModalTitle.textContent = "Clip Sequencer";
            const NUM_CLIPS = 5;
            if (videoFiles.length < NUM_CLIPS) {
              taskModalBody.innerHTML = `<p class="text-red-500">You need at least ${NUM_CLIPS} videos for this challenge.</p>`;
              return;
            }

            taskModalBody.innerHTML = `<h3>Memorize the Sequence!</h3><p>You will be shown ${NUM_CLIPS} clips. Watch carefully.</p><button id="start-challenge-btn" class="modal-action-btn">Start</button>`;

            document.getElementById('start-challenge-btn').onclick = async () => {
              const shuffledIndices = [...videoFiles.keys()].sort(() => 0.5 - Math.random());
              const correctSequence = shuffledIndices.slice(0, NUM_CLIPS);

              taskModalBody.innerHTML = `<div id="memory-video-player-container"><video id="sequencer-player" muted playsinline></video></div>`;
              const player = document.getElementById('sequencer-player');

              for (let i = 0; i < correctSequence.length; i++) {
                const videoIndex = correctSequence[i];
                taskModalTitle.textContent = `Watching Clip ${i + 1} / ${NUM_CLIPS}`;
                const file = videoFiles[videoIndex];
                const url = createTrackedObjectURL(file);
                player.src = url;
                await player.play();
                await new Promise(resolve => setTimeout(resolve, 2500)); // Play each clip for 2.5s
                player.pause();
              }

              renderArrangementPhase(correctSequence);
            };
          }

          function renderArrangementPhase(correctSequence) {
            taskModalTitle.textContent = `Recreate the Sequence`;
            const shuffledSequence = [...correctSequence].sort(() => 0.5 - Math.random());

            taskModalBody.innerHTML = `
                <div class="sequencer-container">
                    <div class="sequencer-drop-zones">
                        ${Array(correctSequence.length).fill(0).map((_, i) => `<div class="sequencer-drop-zone" data-drop-index="${i}">${i+1}</div>`).join('')}
                    </div>
                    <p>Drag the clips from the pool below into the correct order above.</p>
                    <div class="sequencer-clips-pool">
                         ${shuffledSequence.map(index => `
                            <div class="sequencer-draggable-clip" draggable="true" data-video-index="${index}">
                                <video src="${createTrackedObjectURL(videoFiles[index])}#t=0.5" preload="metadata" muted playsinline></video>
                            </div>
                         `).join('')}
                    </div>
                    <button id="check-sequence-btn" class="modal-action-btn mt-4" style="max-width: 200px;">Check Sequence</button>
                </div>
            `;

            // Force video thumbnails to load
            const videoElements = taskModalBody.querySelectorAll('.sequencer-draggable-clip video');
            videoElements.forEach(video => {
              video.load();
              video.addEventListener('loadedmetadata', () => {
                try {
                  video.currentTime = 0.5; // Seek to 0.5 seconds to show a frame
                } catch (e) {
                  // Some videos may not be seekable yet, just use first frame
                  console.log('Could not seek video for thumbnail');
                }
              });
            });

            const draggables = document.querySelectorAll('.sequencer-draggable-clip');
            const dropZones = document.querySelectorAll('.sequencer-drop-zone');
            let userSequence = Array(correctSequence.length).fill(null);

            draggables.forEach(draggable => {
              draggable.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', draggable.dataset.videoIndex);
                setTimeout(() => draggable.style.opacity = '0.5', 0);
              });
              draggable.addEventListener('dragend', () => draggable.style.opacity = '1');
            });

            dropZones.forEach(zone => {
              zone.addEventListener('dragover', e => {
                e.preventDefault();
                zone.classList.add('over');
              });
              zone.addEventListener('dragleave', () => zone.classList.remove('over'));
              zone.addEventListener('drop', e => {
                e.preventDefault();
                zone.classList.remove('over');
                const videoIndex = e.dataTransfer.getData('text/plain');
                const draggableElement = document.querySelector(`.sequencer-draggable-clip[data-video-index='${videoIndex}']`);
                if (draggableElement) {
                  const dropIndex = parseInt(zone.dataset.dropIndex);
                  // If another clip is already here, send it back to the pool
                  if (zone.firstChild && zone.firstChild.dataset) {
                    document.querySelector('.sequencer-clips-pool').appendChild(zone.firstChild);
                  }
                  zone.innerHTML = '';
                  zone.appendChild(draggableElement);
                  userSequence[dropIndex] = parseInt(videoIndex);
                }
              });
            });

            document.getElementById('check-sequence-btn').onclick = () => {
              const isCorrect = userSequence.every((val, index) => val === correctSequence[index]);
              const correctCount = userSequence.filter((val, index) => val === correctSequence[index]).length;
              
              if (isCorrect) {
                updateMainScore(3000);
                showWinLossScreen(correctSequence.length, correctSequence.length, () => markTaskComplete());
              } else {
                updateMainScore(-1000);
                showWinLossScreen(correctCount, correctSequence.length, () => closeTaskModal());
              }
            };
          }

          async function setupAudioAnagramTask() {
            taskModalTitle.textContent = "Say What?";
            const prompt =
              `Generate a JSON object with two properties: "word" and "scrambled_letters". The word should be a 5-8 letter word relevant to pop culture, gay culture, or internet slang. The "scrambled_letters" should be an array of the letters from the word in a random order. Example: {"word": "BOTTOM", "scrambled_letters": ["T","O","M","B","T","O"]}`;
            const schema = {
              type: "OBJECT",
              properties: {
                "word": {
                  "type": "STRING"
                },
                "scrambled_letters": {
                  "type": "ARRAY",
                  "items": {
                    "type": "STRING"
                  }
                }
              },
              required: ["word", "scrambled_letters"]
            };
            const result = await callGemini(prompt, schema);
            if (!result) {
              taskModalBody.innerHTML = `<p style="color: #e74c3c; text-align: center;">Failed to generate audio anagram. Please check your API key and try again.</p>`;
              return;
            }

            try {
              const data = JSON.parse(result);
              const {
                word,
                scrambled_letters
              } = data;

              taskModalBody.innerHTML = `
                    <h3>Listen to the letters and unscramble the word!</h3>
                    <button id="play-anagram-sound" class="modal-action-btn">üîä Play Sound</button>
                `;

              document.getElementById('play-anagram-sound').onclick = () => {
                const textToSpeak = `The letters are: ${scrambled_letters.join('... ')}`;
                speak(textToSpeak, storyMakerVoiceSelect.value);

                let timeLeft = 30;
                taskModalBody.innerHTML = `
                        <div id="task-modal-timer">Time: ${timeLeft}</div>
                        <p class="mb-4">Unscramble the word you just heard.</p>
                        <input type="text" id="anagram-answer" class="w-full task-input-field" placeholder="Type your answer...">
                        <button id="submit-anagram" class="modal-action-btn mt-4">Submit</button>
                    `;
                document.getElementById('anagram-answer').focus();

                modalTimer = setInterval(() => {
                  timeLeft--;
                  const timerEl = document.getElementById('task-modal-timer');
                  if (timerEl) timerEl.textContent = `Time: ${timeLeft}`;
                  if (timeLeft <= 0) {
                    clearInterval(modalTimer);
                    showToast("Time's up!", "warning");
                    closeTaskModal();
                  }
                }, 1000);

                document.getElementById('submit-anagram').onclick = () => {
                  const userAnswer = document.getElementById('anagram-answer').value.trim().toLowerCase();
                  if (userAnswer === word.toLowerCase()) {
                    clearInterval(modalTimer);
                    updateMainScore(2000);
                    markTaskComplete();
                  } else {
                    showToast(`Incorrect! The word was: ${word}`, "error");
                    closeTaskModal();
                  }
                };
              };
            } catch (e) {
              taskModalBody.innerHTML = `<p class="text-red-500">AI returned invalid data. Please try again.</p>`;
            }
          }

          async function setupReflexTestTask() {
            taskModalTitle.textContent = "Watch Closely";
            if (videoFiles.length < 1) {
              taskModalBody.innerHTML = `<p class="text-red-500">You need at least one video for this challenge.</p>`;
              return;
            }

            taskModalBody.innerHTML = `<h3>Click the button ONLY when you see the üòà symbol.</h3><p>Don't click too early!</p><button id="start-challenge-btn" class="modal-action-btn">Start</button>`;

            document.getElementById('start-challenge-btn').onclick = () => {
              const randomVideoIndex = Math.floor(Math.random() * videoFiles.length);
              const videoURL = createTrackedObjectURL(videoFiles[randomVideoIndex]);
              let gamePhase = 'waiting'; // 'waiting', 'active', 'ended'
              let symbolTimer = null;

              taskModalBody.innerHTML = `
                    <div class="reflex-test-container">
                        <video class="reflex-test-video" src="${videoURL}" muted autoplay loop></video>
                        <div class="reflex-test-symbol">üòà</div>
                    </div>
                    <button id="reflex-click-btn" class="modal-action-btn mt-4">CLICK HERE!</button>
                `;

              const symbolEl = document.querySelector('.reflex-test-symbol');

              const showSymbolTimeout = setTimeout(() => {
                gamePhase = 'active';
                symbolEl.classList.add('visible');
                symbolTimer = setTimeout(() => { // Symbol disappears
                  gamePhase = 'ended';
                  symbolEl.classList.remove('visible');
                  if (activeTaskElement && !isTaskCompleted) { // If player hasn't clicked by now
                    showToast('Too slow!', 'warning');
                    closeTaskModal();
                  }
                }, 1500); // Symbol is visible for 1.5s
              }, Math.random() * 5000 + 3000); // Random delay 3-8s

              currentTimers.push(showSymbolTimeout, symbolTimer);

              document.getElementById('reflex-click-btn').onclick = () => {
                  if(gamePhase === 'ended') return;

                  if (gamePhase === 'waiting') {
                    showToast('Too early!', 'warning');
                    clearTimeout(showSymbolTimeout);
                    closeTaskModal();
                  } else if (gamePhase === 'active') {
                    updateMainScore(2000);
                    markTaskComplete();
                  }
                  gamePhase = 'ended'; // Prevent multiple clicks
              };
            };
          }

          // --- Pressure Front Challenge ---
          async function setupPressureFrontTask() {
            taskModalTitle.textContent = "Pressure Front";
            const currentPlayer = challengePlayers[currentChallengePlayerIndex];
            
            // Preset options for duration and change interval
            const presetOptions = [
              { duration: 100, change: 5 },
              { duration: 75, change: 5 },
              { duration: 30, change: 5 },
              { duration: 100, change: 10 },
              { duration: 50, change: 10 }
            ];
            const defaultPreset = presetOptions[0];
            
            taskModalBody.innerHTML = `
              <h3>Player ${currentChallengePlayerIndex + 1}'s Turn</h3>
              <p>Set up your guess and watch the videos!</p>
              <div style="margin: 1rem 0;">
                <label>Preset Options: 
                  <select id="pf-preset" style="padding: 0.5rem; pointer-events: auto; background: rgba(255,255,255,0.1); color: black; border-radius: 4px;">
                    ${presetOptions.map((opt, i) => `<option value="${i}">Duration ${opt.duration}s, Change ${opt.change}s</option>`).join('')}
                  </select>
                </label>
              </div>
              <div style="margin: 1rem 0;">
                <label>Time Duration (seconds): <input type="number" id="pf-timer" value="${defaultPreset.duration}" min="10" max="120" style="width: 80px; pointer-events: auto; color: black;"></label>
              </div>
              <div style="margin: 1rem 0;">
                <label>Video Change Interval (seconds): <input type="number" id="pf-interval" value="${defaultPreset.change}" min="1" max="30" style="width: 80px; pointer-events: auto; color: black;"></label>
              </div>
              <div style="margin: 1rem 0;">
                <label>Your guess emoji: </label>
                <span class="pf-emoji-cycler text-2xl cursor-pointer" style="display: inline-block; padding: 0.5rem; background: rgba(255,255,255,0.1); border-radius: 5px;">üçÜ</span>
              </div>
              <div style="margin: 1rem 0;">
                <label>Your guess count: <input type="number" id="pf-guess-count" value="5" min="0" max="100" style="width: 80px; pointer-events: auto; color: black;"></label>
              </div>
              <button id="start-pf-btn" class="modal-action-btn">Start Game</button>
            `;
            
            const guessEmojis = ['üçÜ', 'üçë', 'üë§', 'üôÇ'];
            const emojiCycler = taskModalBody.querySelector('.pf-emoji-cycler');
            parseEmojis(emojiCycler);
            
            // Preset selector handler
            const presetSelector = document.getElementById('pf-preset');
            const timerInput = document.getElementById('pf-timer');
            const intervalInput = document.getElementById('pf-interval');
            
            presetSelector.addEventListener('change', () => {
              const selectedPreset = presetOptions[parseInt(presetSelector.value)];
              timerInput.value = selectedPreset.duration;
              intervalInput.value = selectedPreset.change;
            });
            
            // Ensure inputs are focusable
            const inputs = taskModalBody.querySelectorAll('input[type="number"]');
            inputs.forEach(input => {
              input.style.pointerEvents = 'auto';
              input.addEventListener('focus', (e) => {
                e.stopPropagation();
              });
            });
            
            emojiCycler.addEventListener('click', () => {
              let currentEmojiIndex = guessEmojis.indexOf(emojiCycler.textContent.trim());
              currentEmojiIndex = (currentEmojiIndex + 1) % guessEmojis.length;
              emojiCycler.textContent = guessEmojis[currentEmojiIndex];
              parseEmojis(emojiCycler);
            });
            
            document.getElementById('start-pf-btn').onclick = () => {
              if (videoFiles.length === 0) {
                showToast("Please upload videos first.", "warning");
                return;
              }
              
              const duration = parseInt(document.getElementById('pf-timer').value);
              const interval = parseInt(document.getElementById('pf-interval').value);
              const guessEmoji = emojiCycler.textContent.trim();
              const guessCount = parseInt(document.getElementById('pf-guess-count').value);
              
              // Hide modal overlay to show video clearly
              taskModalOverlay.style.pointerEvents = 'none';
              taskModalBody.innerHTML = '';
              
              // Create overlay for tally in corner of video canvas
              const gameOverlay = document.createElement('div');
              gameOverlay.id = 'pf-game-overlay';
              gameOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                z-index: 250;
                pointer-events: none;
              `;
              
              // Tally container in top-right corner
              const tallyContainer = document.createElement('div');
              tallyContainer.style.cssText = `
                position: absolute;
                top: 20px;
                right: 20px;
                background: rgba(0,0,0,0.8);
                padding: 1rem;
                border-radius: 8px;
                pointer-events: auto;
                z-index: 10;
              `;
              
              // Add timer and guess info
              const infoDiv = document.createElement('div');
              infoDiv.style.cssText = 'text-align: center; margin-bottom: 1rem;';
              infoDiv.innerHTML = `
                <div style="color: #8b5cf6; font-weight: bold; margin-bottom: 0.5rem;">Player ${currentChallengePlayerIndex + 1}</div>
                <div style="color: #10b981; margin-bottom: 0.5rem;">Guess: ${guessEmoji} √ó ${guessCount}</div>
                <div id="pf-timer-display" style="color: #f59e0b; font-size: 1.5rem; font-weight: bold;">Time: ${duration}s</div>
              `;
              tallyContainer.appendChild(infoDiv);
              parseEmojis(infoDiv);
              
              // Add emoji tally buttons
              const tallyGrid = document.createElement('div');
              tallyGrid.style.cssText = 'display: flex; gap: 0.5rem; flex-wrap: wrap; max-width: 200px;';
              
              const tallyCounts = {};
              
              guessEmojis.forEach(emoji => {
                tallyCounts[emoji] = 0;
                const tallyDiv = document.createElement('div');
                tallyDiv.style.cssText = 'text-align: center; padding: 0.75rem; background: rgba(255,255,255,0.1); border-radius: 8px; cursor: pointer; user-select: none; flex: 1 1 45%;';
                tallyDiv.innerHTML = `<div style="font-size: 1.5rem;">${emoji}</div><div class="tally-count" style="font-size: 1.2rem; font-weight: bold;">0</div>`;
                
                tallyDiv.addEventListener('click', () => {
                  tallyCounts[emoji]++;
                  tallyDiv.querySelector('.tally-count').textContent = tallyCounts[emoji];
                });
                
                tallyGrid.appendChild(tallyDiv);
              });
              
              tallyContainer.appendChild(tallyGrid);
              gameOverlay.appendChild(tallyContainer);
              document.body.appendChild(gameOverlay);
              
              parseEmojis(tallyContainer);
              
              // Start video rotation
              let videoChangeTimer = null;
              if (interval > 0) {
                advanceVideo(1);
                videoChangeTimer = setInterval(() => advanceVideo(1), interval * 1000);
                currentTimers.push(videoChangeTimer);
              }
              
              // Countdown timer
              let timeLeft = duration;
              const timerDisplay = document.getElementById('pf-timer-display');
              const countdownTimer = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = `Time: ${timeLeft}s`;
                
                if (timeLeft <= 0) {
                  clearInterval(countdownTimer);
                  if (videoChangeTimer) clearInterval(videoChangeTimer);
                  
                  // Calculate winner
                  const actualCount = tallyCounts[guessEmoji];
                  const difference = Math.abs(actualCount - guessCount);
                  
                  // Remove overlay and show results in modal
                  gameOverlay.remove();
                  taskModalOverlay.style.pointerEvents = 'all';
                  
                  taskModalBody.innerHTML = `
                    <h2>Results</h2>
                    <p style="font-size: 1.5rem;">Your guess: ${guessEmoji} √ó ${guessCount}</p>
                    <p style="font-size: 1.5rem;">Actual count: ${guessEmoji} √ó ${actualCount}</p>
                    <p style="font-size: 1.5rem;">Difference: ${difference}</p>
                    <p style="font-size: 1.2rem; margin-top: 1rem;">${difference <= 2 ? 'üéâ Close enough! You win!' : '‚ùå Not close enough. Try again!'}</p>
                    <button id="pf-finish-btn" class="modal-action-btn mt-4">${difference <= 2 ? 'Claim Square' : 'Continue'}</button>
                  `;
                  
                  parseEmojis(taskModalBody);
                  
                  document.getElementById('pf-finish-btn').onclick = () => {
                    if (difference <= 2) {
                      updateMainScore(1500);
                      markTaskComplete();
                    } else {
                      closeTaskModal();
                    }
                  };
                }
              }, 1000);
              
              currentTimers.push(countdownTimer);
            };
          }

          // --- Mini Bingo Challenge ---
          async function setupMiniBingoTask() {
            taskModalTitle.textContent = "Mini Bingo (2x2)";
            const currentPlayer = challengePlayers[currentChallengePlayerIndex];
            
            taskModalBody.innerHTML = `
              <h3>Player ${currentChallengePlayerIndex + 1}'s Turn</h3>
              <p>Create a 2x2 bingo card (select 4 prompts)</p>
              <button id="start-minibingo-btn" class="modal-action-btn">Start Building</button>
            `;
            
            document.getElementById('start-minibingo-btn').onclick = () => {
              let selectedPrompts = [];
              // Pick 12 random prompts from the full list
              const miniPrompts = [...bingoPrompts].sort(() => 0.5 - Math.random()).slice(0, 12);
              
              taskModalBody.innerHTML = `
                <p>Select 4 prompts from the list below:</p>
                <div id="minibingo-master-list" style="max-height: 300px; overflow-y: auto; margin: 1rem 0;">
                  ${miniPrompts.map(p => `<div class="bingo-item" style="padding: 0.5rem; margin: 0.25rem 0; background: rgba(255,255,255,0.1); border-radius: 4px; cursor: pointer;">${p}</div>`).join('')}
                </div>
                <h3>Your Card Preview (<span id="minibingo-pick-count">0</span>/4)</h3>
                <div id="minibingo-card-preview" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin: 1rem 0;">
                  ${Array(4).fill('<div class="cell" style="padding: 1rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; min-height: 60px;"></div>').join('')}
                </div>
                <button id="confirm-minibingo-card" class="modal-action-btn mt-4" disabled>Create Card</button>
              `;
              
              const updatePreview = () => {
                const cells = document.querySelectorAll('#minibingo-card-preview .cell');
                cells.forEach((cell, i) => {
                  cell.textContent = selectedPrompts[i] || '';
                });
                document.getElementById('minibingo-pick-count').textContent = selectedPrompts.length;
                document.getElementById('confirm-minibingo-card').disabled = selectedPrompts.length !== 4;
              };
              
              document.querySelectorAll('#minibingo-master-list .bingo-item').forEach(item => {
                item.addEventListener('pointerdown', () => {
                  const prompt = item.textContent;
                  if (item.classList.contains('selected')) {
                    item.classList.remove('selected');
                    item.style.background = 'rgba(255,255,255,0.1)';
                    selectedPrompts = selectedPrompts.filter(p => p !== prompt);
                  } else if (selectedPrompts.length < 4) {
                    item.classList.add('selected');
                    item.style.background = 'rgba(76, 175, 80, 0.3)';
                    selectedPrompts.push(prompt);
                  }
                  updatePreview();
                };
              });
              
              document.getElementById('confirm-minibingo-card').addEventListener('pointerdown', () => {
                // Create the mini bingo card widget
                const card = document.createElement('div');
                card.className = 'bingo-card-widget';
                card.style.cssText = 'position: fixed; background: rgba(31, 31, 31, 0.95); border: 2px solid #fff; border-radius: 6px; padding: 0.5rem; z-index: 1000; min-width: 180px; width: 180px;';
                card.style.top = `${Math.random() * 30 + 30}vh`;
                card.style.left = `${Math.random() * 40 + 30}vw`;
                
                const currentPlayer = challengePlayers[currentChallengePlayerIndex];
                const playerName = currentPlayer ? currentPlayer.name : 'Mini Bingo';
                card.innerHTML = `
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; padding: 2px 4px;">
                    <span style="font-weight: bold; font-size: 0.85rem;">${playerName}</span>
                    <button class="minibingo-close-btn" style="background: none; border: none; color: #fff; font-size: 1.2rem; cursor: pointer; padding: 0; width: 24px; height: 24px; line-height: 1;">&times;</button>
                  </div>
                  <div class="minibingo-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.3rem;">
                    ${selectedPrompts.map(prompt => `<div class="minibingo-cell" style="padding: 0.4rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 3px; cursor: pointer; font-size: 0.65rem; text-align: center; line-height: 1.1;">${prompt}</div>`).join('')}
                  </div>
                `;
                
                document.body.appendChild(card);
                
                let markedCount = 0;
                const cells = card.querySelectorAll('.minibingo-cell');
                cells.forEach(cell => {
                  cell.addEventListener('click', () => {
                    if (!cell.classList.contains('marked')) {
                      cell.classList.add('marked');
                      cell.style.background = 'rgba(76, 175, 80, 0.5)';
                      cell.style.textDecoration = 'line-through';
                      markedCount++;
                      
                      if (markedCount === 4) {
                        setTimeout(() => {
                          showToast('üéâ Mini Bingo! You marked all 4!', 'success');
                          card.remove();
                          updateMainScore(1000);
                          markTaskComplete();
                        }, 300);
                      }
                    }
                  });
                });
                
                card.querySelector('.minibingo-close-btn').onclick = () => {
                  card.remove();
                };
                
                closeTaskModal();
              };
              
              updatePreview();
            };
          }

          // --- Splash Click Challenge ---
          async function setupSplashClickTask() {
            taskModalTitle.textContent = "Splash Click";
            const currentPlayer = challengePlayers[currentChallengePlayerIndex];
            
            // Get a word from the current video filename for the label
            let videoWord = "Challenge";
            if (videoFiles.length > 0 && currentVideoIndex >= 0 && currentVideoIndex < videoFiles.length) {
              const filename = videoFiles[currentVideoIndex].name;
              const words = filename.replace(/\.[^/.]+$/, "").split(/[\s_-]+/).filter(w => w.length > 3);
              videoWord = words.length > 0 ? words[0].charAt(0).toUpperCase() + words[0].slice(1) : "Challenge";
            }
            
            taskModalBody.innerHTML = `
              <h3>Player ${currentChallengePlayerIndex + 1}'s Turn</h3>
              <p>Click the target emojis as they appear over the video!</p>
              <p style="color: #fbbf24;">Get 10 targets to win! Time limit: 30 seconds</p>
              <p style="color: #8b5cf6;">Faster clicks = bigger bonus!</p>
              <button id="start-splash-btn" class="modal-action-btn">Start Game</button>
            `;
            
            parseEmojis(taskModalBody);
            
            document.getElementById('start-splash-btn').onclick = () => {
              // Varied target and decoy emojis - ensure no overlap
              const possibleTargets = ['üí¶', '‚≠ê', 'üåü', '‚ú®', 'üíé', 'üîÆ'];
              const targetEmoji = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
              const allDecoys = ['üî•', 'üí®', '‚ö°', 'üåä', '‚ùÑÔ∏è', '‚òÄÔ∏è', 'üåô', 'üí´', 'üåà', '‚òÅÔ∏è'];
              const decoyEmojis = allDecoys.filter(e => e !== targetEmoji);
              
              let correctClicks = 0;
              let gameOver = false;
              const startTime = Date.now();
              
              // Close the modal and show minimal overlay over video
              taskModalOverlay.style.pointerEvents = 'none'; // Allow clicks through to video overlay
              taskModalBody.innerHTML = ''; // Clear modal content but keep modal visible with dark background
              
              // Create overlay container over the video
              const gameOverlay = document.createElement('div');
              gameOverlay.id = 'splash-click-overlay';
              gameOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                z-index: 250;
                pointer-events: none;
              `;
              
              // Info panel at top (minimal, semi-transparent)
              const infoPanel = document.createElement('div');
              infoPanel.style.cssText = `
                position: absolute;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.7);
                padding: 0.5rem 1rem;
                border-radius: 8px;
                display: flex;
                gap: 2rem;
                align-items: center;
                pointer-events: none;
                z-index: 10;
              `;
              infoPanel.innerHTML = `
                <div style="color: #8b5cf6; font-weight: bold;">Studio Challenge: ${videoWord}</div>
                <div style="color: #3b82f6; font-weight: bold;">Player ${currentChallengePlayerIndex + 1}'s Turn</div>
                <div id="splash-score-display" style="color: #10b981; font-weight: bold;">Score: 0/10</div>
                <div id="splash-timer-display" style="color: #f59e0b; font-weight: bold;">Time: 30s</div>
              `;
              gameOverlay.appendChild(infoPanel);
              
              // Feedback container for tick/cross
              const feedbackContainer = document.createElement('div');
              feedbackContainer.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 5rem;
                pointer-events: none;
                z-index: 15;
                transition: opacity 0.3s;
                opacity: 0;
              `;
              gameOverlay.appendChild(feedbackContainer);
              
              document.body.appendChild(gameOverlay);
              
              const scoreDisplay = document.getElementById('splash-score-display');
              const timerDisplay = document.getElementById('splash-timer-display');
              
              const showFeedback = (isCorrect) => {
                feedbackContainer.textContent = isCorrect ? '‚úîÔ∏è' : '‚úñÔ∏è';
                feedbackContainer.style.opacity = '1';
                parseEmojis(feedbackContainer);
                setTimeout(() => {
                  feedbackContainer.style.opacity = '0';
                }, 500);
              };
              
              const spawnEmoji = () => {
                if (gameOver) return;
                
                const emojiEl = document.createElement('div');
                // 50% chance for target, 50% for random decoy
                const isTarget = Math.random() < 0.5;
                const emoji = isTarget ? targetEmoji : decoyEmojis[Math.floor(Math.random() * decoyEmojis.length)];
                emojiEl.textContent = emoji;
                emojiEl.style.cssText = `
                  position: absolute;
                  font-size: 2.5rem;
                  cursor: pointer;
                  pointer-events: auto;
                  transition: transform 0.1s;
                  top: ${Math.random() * 70 + 15}%;
                  left: ${Math.random() * 80 + 10}%;
                  text-shadow: 0 0 4px rgba(0,0,0,0.8);
                `;
                
                emojiEl.addEventListener('click', (e) => {
                  e.stopPropagation();
                  if (gameOver) return;
                  
                  if (emoji === targetEmoji) {
                    correctClicks++;
                    scoreDisplay.textContent = `Score: ${correctClicks}/10`;
                    showFeedback(true);
                    emojiEl.remove();
                    
                    if (correctClicks >= 10) {
                      gameOver = true;
                      clearInterval(spawnInterval);
                      clearInterval(gameTimer);
                      
                      // Calculate time-based bonus
                      const elapsedTime = (Date.now() - startTime) / 1000;
                      const baseScore = 2000;
                      const timeBonus = Math.max(0, Math.floor((30 - elapsedTime) * 50));
                      const totalScore = baseScore + timeBonus;
                      
                      gameOverlay.remove();
                      taskModalOverlay.style.pointerEvents = 'all';
                      taskModalBody.innerHTML = `
                        <h2>üéâ Victory!</h2>
                        <p style="font-size: 1.3rem; margin: 1rem 0;">Completed in ${elapsedTime.toFixed(1)}s</p>
                        <p style="font-size: 1.1rem;">Base Score: ${baseScore}</p>
                        <p style="font-size: 1.1rem; color: #10b981;">Time Bonus: +${timeBonus}</p>
                        <p style="font-size: 1.5rem; font-weight: bold; margin-top: 1rem;">Total: ${totalScore} points</p>
                        <button id="splash-finish-btn" class="modal-action-btn mt-4">Claim Square</button>
                      `;
                      
                      parseEmojis(taskModalBody);
                      
                      document.getElementById('splash-finish-btn').onclick = () => {
                        updateMainScore(totalScore);
                        markTaskComplete();
                      };
                    }
                  } else {
                    gameOver = true;
                    clearInterval(spawnInterval);
                    clearInterval(gameTimer);
                    showFeedback(false);
                    
                    setTimeout(() => {
                      gameOverlay.remove();
                      taskModalOverlay.style.pointerEvents = 'all';
                      closeTaskModal();
                    }, 800);
                  }
                });
                
                gameOverlay.appendChild(emojiEl);
                parseEmojis(emojiEl);
                
                setTimeout(() => {
                  if (!gameOver && emojiEl.parentNode) {
                    emojiEl.remove();
                  }
                }, 2500);
              };
              
              // Spawn emojis every 700ms
              const spawnInterval = setInterval(() => {
                if (gameOver) {
                  clearInterval(spawnInterval);
                } else {
                  spawnEmoji();
                }
              }, 700);
              
              currentTimers.push(spawnInterval);
              
              // 30 second timer
              let timeLeft = 30;
              const gameTimer = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = `Time: ${timeLeft}s`;
                
                if (timeLeft <= 0 && !gameOver) {
                  gameOver = true;
                  clearInterval(spawnInterval);
                  clearInterval(gameTimer);
                  
                  gameOverlay.remove();
                  taskModalOverlay.style.pointerEvents = 'all';
                  taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚è∞ Time's Up!</h2><p>Not enough targets found.</p></div>`;
                  setTimeout(() => closeTaskModal(), 2000);
                }
              }, 1000);
              
              currentTimers.push(gameTimer);
            };
          }

          // --- Weather Gamble Challenge ---
          async function setupWeatherGambleTask() {
            taskModalTitle.textContent = "Weather Gamble";
            const currentPlayer = challengePlayers[currentChallengePlayerIndex];
            
            taskModalBody.innerHTML = `
              <h3>Player ${currentChallengePlayerIndex + 1}'s Turn</h3>
              <p style="font-size: 1.3rem; margin: 2rem 0;">Will the forecast be sunny or stormy?</p>
              <div style="display: flex; gap: 2rem; justify-content: center; margin: 2rem 0;">
                <button id="choose-sunny" class="modal-action-btn" style="font-size: 2rem; padding: 2rem;">‚òÅÔ∏è Sunny</button>
                <button id="choose-stormy" class="modal-action-btn" style="font-size: 2rem; padding: 2rem;">‚ö° Stormy</button>
              </div>
            `;
            
            parseEmojis(taskModalBody);
            
            const SUNNY_PROBABILITY = 0.7; // 70% sunny, 30% stormy
            
            const handleChoice = (choice) => {
              const result = Math.random() < SUNNY_PROBABILITY ? 'sunny' : 'stormy';
              const resultEmoji = result === 'sunny' ? '‚òÅÔ∏è' : '‚ö°';
              const resultText = result === 'sunny' ? 'Sunny' : 'Stormy';
              
              taskModalBody.innerHTML = `
                <div style="text-align: center;">
                  <h2>The forecast is...</h2>
                  <div style="font-size: 8rem; margin: 2rem 0; animation: pulse 0.5s;">${resultEmoji}</div>
                  <h2>${resultText}!</h2>
                  <p style="font-size: 1.2rem; margin: 2rem 0;">You chose: ${choice === 'sunny' ? '‚òÅÔ∏è Sunny' : '‚ö° Stormy'}</p>
                  <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
                    <button id="claim-square-btn" class="modal-action-btn">‚úÖ Claim Square</button>
                    <button id="pass-btn" class="modal-action-btn">‚ùå Pass</button>
                  </div>
                </div>
              `;
              
              parseEmojis(taskModalBody);
              
              document.getElementById('claim-square-btn').onclick = () => {
                if (choice === result) {
                  taskModalBody.innerHTML = '<div style="text-align: center; font-size: 2rem; padding: 2rem;">üéâ You win the square!</div>';
                  setTimeout(() => {
                    updateMainScore(1000);
                    markTaskComplete();
                  }, 1000);
                } else {
                  taskModalBody.innerHTML = '<div style="text-align: center; font-size: 2rem; padding: 2rem;">‚ùå Wrong guess! No square.</div>';
                  setTimeout(() => closeTaskModal(), 1500);
                }
              };
              
              document.getElementById('pass-btn').onclick = () => {
                closeTaskModal();
              };
            };
            
            document.getElementById('choose-sunny').addEventListener('pointerdown', () => handleChoice('sunny'));
            document.getElementById('choose-stormy').addEventListener('pointerdown', () => handleChoice('stormy'));
          }

          // --- NEW MINI GAMES ---

          // 1. Video Clip Detective - 6 5-second clips, identify which has filter/slomo/reverse/shorter/double play
          async function setupVideoClipDetectiveTask() {
            taskModalTitle.textContent = "Video Clip Detective üîç";
            
            if (videoFiles.length < 6) {
              taskModalBody.innerHTML = `<p class="text-red-500">You need at least 6 videos for this challenge.</p>`;
              return;
            }

            taskModalBody.innerHTML = `
              <h3>Watch closely!</h3>
              <p>6 clips will play. One has a special effect:</p>
              <ul style="list-style: disc; margin-left: 2rem; margin-top: 1rem;">
                <li>Slowed down (half speed)</li>
                <li>Played twice</li>
                <li>Played in reverse</li>
                <li>Shorter duration</li>
                <li>Filter applied</li>
              </ul>
              <p style="margin-top: 1rem;">Identify which clip at the end!</p>
              <button id="start-challenge-btn" class="modal-action-btn">Start Watching</button>
            `;

            document.getElementById('start-challenge-btn').onclick = async () => {
              // Pick 6 random videos
              const shuffled = [...videoFiles.keys()].sort(() => 0.5 - Math.random());
              const selectedIndices = shuffled.slice(0, 6);
              
              // Pick which one will be special (0-5)
              const specialIndex = Math.floor(Math.random() * 6);
              
              // Pick what effect
              const effects = ['slomo', 'double', 'reverse', 'short', 'filter'];
              const specialEffect = effects[Math.floor(Math.random() * effects.length)];
              
              taskModalBody.innerHTML = `
                <div id="detective-video-container" style="width: 100%; max-width: 500px; margin: 0 auto;">
                  <video id="detective-player" style="width: 100%; height: auto;" muted playsinline></video>
                </div>
                <p style="margin-top: 1rem; font-size: 1.2rem;">Watching clip <span id="clip-number">1</span>/6...</p>
              `;
              
              const player = document.getElementById('detective-player');
              
              for (let i = 0; i < 6; i++) {
                document.getElementById('clip-number').textContent = i + 1;
                const videoIndex = selectedIndices[i];
                const file = videoFiles[videoIndex];
                const url = createTrackedObjectURL(file);
                
                player.src = url;
                await new Promise(resolve => {
                  player.onloadedmetadata = () => resolve();
                });
                
                const isSpecial = i === specialIndex;
                let playDuration = 5000; // 5 seconds default
                
                if (isSpecial) {
                  if (specialEffect === 'slomo') {
                    player.playbackRate = 0.5;
                  } else if (specialEffect === 'reverse') {
                    player.classList.add('video-reversed');
                  } else if (specialEffect === 'short') {
                    playDuration = 3000; // 3 seconds
                  } else if (specialEffect === 'filter') {
                    player.classList.add('video-sepia');
                  }
                } else {
                  player.playbackRate = 1;
                  player.className = '';
                }
                
                player.currentTime = Math.random() * Math.max(0, player.duration - 5);
                await player.play();
                
                if (isSpecial && specialEffect === 'double') {
                  // Play twice
                  await new Promise(resolve => setTimeout(resolve, 2500));
                  player.currentTime = Math.max(0, player.currentTime - 2.5);
                  await new Promise(resolve => setTimeout(resolve, 2500));
                } else {
                  await new Promise(resolve => setTimeout(resolve, playDuration));
                }
                
                player.pause();
                player.className = '';
                player.playbackRate = 1;
              }
              
              // Show selection screen
              taskModalTitle.textContent = "Which clip was different?";
              taskModalBody.innerHTML = `
                <p style="margin-bottom: 1rem;">The special effect was: <strong>${specialEffect}</strong></p>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
                  ${[0, 1, 2, 3, 4, 5].map(i => `
                    <button class="modal-action-btn" data-clip="${i}" style="font-size: 1.5rem;">
                      Clip ${i + 1}
                    </button>
                  `).join('')}
                </div>
              `;
              
              document.querySelectorAll('button[data-clip]').forEach(btn => {
                btn.onclick = () => {
                  const chosen = parseInt(btn.dataset.clip);
                  if (chosen === specialIndex) {
                    taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>üéâ Correct!</h2><p>You found the ${specialEffect} clip!</p></div>`;
                    setTimeout(() => {
                      updateMainScore(2000);
                      markTaskComplete();
                    }, 1500);
                  } else {
                    taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚ùå Wrong!</h2><p>It was clip ${specialIndex + 1}</p></div>`;
                    setTimeout(() => closeTaskModal(), 2000);
                  }
                };
              });
            };
          }

          // Clip Order Memory - Show 6 clips in order, player must recall the order
          async function setupClipOrderMemoryTask() {
            taskModalTitle.textContent = "Clip Order Memory üé¨";
            
            if (videoFiles.length < 6) {
              taskModalBody.innerHTML = `<p class="text-red-500">You need at least 6 videos for this challenge.</p>`;
              return;
            }

            taskModalBody.innerHTML = `
              <h3>Memory Challenge!</h3>
              <p>Watch 6 clips play in order.</p>
              <p>Then, select them in the correct order!</p>
              <button id="start-challenge-btn" class="modal-action-btn">Start Watching</button>
            `;

            document.getElementById('start-challenge-btn').onclick = async () => {
              // Pick 6 random videos
              const shuffled = [...videoFiles.keys()].sort(() => 0.5 - Math.random());
              const selectedIndices = shuffled.slice(0, 6);
              const correctOrder = [...selectedIndices];
              
              // Play all 6 clips in sequence
              taskModalBody.innerHTML = `
                <div id="memory-video-container" style="width: 100%; max-width: 500px; margin: 0 auto;">
                  <video id="memory-player" style="width: 100%; height: auto;" muted playsinline></video>
                </div>
                <p style="margin-top: 1rem; font-size: 1.2rem;">Clip <span id="clip-number">1</span>/6</p>
                <p style="font-size: 0.9rem; color: #8b5cf6;">Remember the order!</p>
              `;
              
              const player = document.getElementById('memory-player');
              
              for (let i = 0; i < 6; i++) {
                document.getElementById('clip-number').textContent = i + 1;
                const videoIndex = selectedIndices[i];
                const file = videoFiles[videoIndex];
                const url = createTrackedObjectURL(file);
                
                player.src = url;
                await new Promise(resolve => {
                  player.onloadedmetadata = () => resolve();
                });
                
                // Play 5-second clip
                player.currentTime = Math.random() * Math.max(0, player.duration - 5);
                await player.play();
                await new Promise(resolve => setTimeout(resolve, 5000));
                player.pause();
              }
              
              // Now show selection screen with video thumbnails
              taskModalTitle.textContent = "Select the Order";
              
              // Create video thumbnails for selection
              const clipThumbnails = await Promise.all(selectedIndices.map(async (videoIndex, i) => {
                const file = videoFiles[videoIndex];
                const url = createTrackedObjectURL(file);
                const video = document.createElement('video');
                video.src = url;
                await new Promise(resolve => {
                  video.onloadedmetadata = () => {
                    video.currentTime = Math.random() * Math.max(0, video.duration - 1);
                    resolve();
                  };
                });
                
                // Wait for seek to complete
                await new Promise(resolve => {
                  video.onseeked = () => resolve();
                });
                
                const canvas = document.createElement('canvas');
                canvas.width = 160;
                canvas.height = 90;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                return {
                  videoIndex,
                  thumbnail: canvas.toDataURL(),
                  originalIndex: i
                };
              }));
              
              // Shuffle clips for display
              const shuffledClips = [...clipThumbnails].sort(() => 0.5 - Math.random());
              
              let userOrder = [];
              
              const renderSelectionScreen = () => {
                taskModalBody.innerHTML = `
                  <p style="margin-bottom: 1rem;">Click the clips in the order they were shown:</p>
                  <div style="margin-bottom: 1rem;">
                    <strong>Your Selection:</strong> ${userOrder.map((_, i) => i + 1).join(', ') || 'None yet'}
                  </div>
                  <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin-bottom: 1rem;">
                    ${shuffledClips.map((clip, i) => {
                      const orderNum = userOrder.indexOf(clip.videoIndex);
                      const isSelected = orderNum !== -1;
                      return `
                        <div class="clip-selection-tile" data-video-index="${clip.videoIndex}" style="
                          position: relative;
                          cursor: ${isSelected ? 'default' : 'pointer'};
                          opacity: ${isSelected ? '0.5' : '1'};
                          border: 2px solid ${isSelected ? '#10b981' : 'rgba(255,255,255,0.3)'};
                          border-radius: 8px;
                          overflow: hidden;
                        ">
                          <img src="${clip.thumbnail}" style="width: 100%; display: block;" />
                          ${isSelected ? `<div style="position: absolute; top: 5px; right: 5px; background: #10b981; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: bold;">${orderNum + 1}</div>` : ''}
                        </div>
                      `;
                    }).join('')}
                  </div>
                  <div style="display: flex; gap: 1rem; justify-content: center;">
                    <button id="reset-order-btn" class="modal-action-btn" ${userOrder.length === 0 ? 'disabled' : ''}>Reset</button>
                    <button id="confirm-order-btn" class="modal-action-btn" ${userOrder.length !== 6 ? 'disabled' : ''}>Confirm</button>
                  </div>
                `;
                
                // Add click handlers
                document.querySelectorAll('.clip-selection-tile').forEach(tile => {
                  const videoIndex = parseInt(tile.dataset.videoIndex);
                  if (!userOrder.includes(videoIndex)) {
                    tile.addEventListener('pointerdown', () => {
                      userOrder.push(videoIndex);
                      renderSelectionScreen();
                    });
                  }
                });
                
                const resetBtn = document.getElementById('reset-order-btn');
                if (resetBtn && !resetBtn.disabled) {
                  resetBtn.addEventListener('pointerdown', () => {
                    userOrder = [];
                    renderSelectionScreen();
                  });
                }
                
                const confirmBtn = document.getElementById('confirm-order-btn');
                if (confirmBtn && !confirmBtn.disabled) {
                  confirmBtn.addEventListener('pointerdown', () => {
                    // Check if order is correct
                    const isCorrect = userOrder.every((val, idx) => val === correctOrder[idx]);
                    
                    if (isCorrect) {
                      taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>üéâ Perfect!</h2><p>You got the order exactly right!</p></div>`;
                      setTimeout(() => {
                        updateMainScore(3000);
                        markTaskComplete();
                      }, 1500);
                    } else {
                      taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚ùå Incorrect!</h2><p>The order wasn't quite right.</p></div>`;
                      setTimeout(() => closeTaskModal(), 2000);
                    }
                  };
                }
              };
              
              renderSelectionScreen();
            };
          }

          // 2. Avatar Sequence Memory - Flash 4/5/6 grid avatars, click sequence 3 times
          async function setupAvatarSequenceTask() {
            taskModalTitle.textContent = "Avatar Sequence Memory üß†";
            
            taskModalBody.innerHTML = `
              <h3>Memorize the sequence!</h3>
              <p>Grid tiles will flash in sequence.</p>
              <p>You must click them in the same order.</p>
              <p><strong>Complete 3 rounds to win!</strong></p>
              <button id="start-challenge-btn" class="modal-action-btn">Start</button>
            `;

            document.getElementById('start-challenge-btn').onclick = () => {
              let round = 1;
              const maxRounds = 3;
              
              const playRound = () => {
                const sequenceLength = 3 + round; // 4, 5, 6
                const gridSize = 9; // 3x3 grid
                
                // Generate random sequence
                const sequence = [];
                for (let i = 0; i < sequenceLength; i++) {
                  sequence.push(Math.floor(Math.random() * gridSize));
                }
                
                // Select 9 images from shuffle-bag (ensures all 34 are used over time)
                const tileImages = [];
                for (let i = 0; i < gridSize; i++) {
                  const imageNum = getNextImage();
                  tileImages.push(`images/${imageNum}.png`);
                }
                
                taskModalTitle.textContent = `Round ${round}/${maxRounds} - Watch the sequence!`;
                taskModalBody.innerHTML = `
                  <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; max-width: 400px; margin: 0 auto;">
                    ${Array(gridSize).fill(0).map((_, i) => `
                      <div class="avatar-tile" data-index="${i}" style="
                        aspect-ratio: 1;
                        background-image: url('${tileImages[i]}');
                        background-size: cover;
                        background-position: center;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.3s;
                        border: 3px solid rgba(255,255,255,0.1);
                      "></div>
                    `).join('')}
                  </div>
                `;
                
                // Show sequence
                let showIndex = 0;
                const showInterval = setInterval(() => {
                  if (showIndex >= sequence.length) {
                    clearInterval(showInterval);
                    // Now let player repeat
                    startPlayerTurn();
                    return;
                  }
                  
                  const tileIndex = sequence[showIndex];
                  const tile = document.querySelector(`.avatar-tile[data-index="${tileIndex}"]`);
                  tile.style.borderColor = 'rgba(52, 152, 219, 1)';
                  tile.style.borderWidth = '5px';
                  tile.style.transform = 'scale(1.1)';
                  tile.style.boxShadow = '0 0 20px rgba(52, 152, 219, 0.8)';
                  
                  setTimeout(() => {
                    tile.style.borderColor = 'rgba(255,255,255,0.1)';
                    tile.style.borderWidth = '3px';
                    tile.style.transform = 'scale(1)';
                    tile.style.boxShadow = 'none';
                  }, 500);
                  
                  showIndex++;
                }, 1000);
                
                currentTimers.push(showInterval);
                
                const startPlayerTurn = () => {
                  taskModalTitle.textContent = `Round ${round}/${maxRounds} - Your turn!`;
                  const playerSequence = [];
                  
                  document.querySelectorAll('.avatar-tile').forEach(tile => {
                    tile.onclick = () => {
                      const index = parseInt(tile.dataset.index);
                      playerSequence.push(index);
                      
                      tile.style.borderColor = 'rgba(46, 204, 113, 1)';
                      tile.style.borderWidth = '5px';
                      tile.style.boxShadow = '0 0 20px rgba(46, 204, 113, 0.8)';
                      setTimeout(() => {
                        tile.style.borderColor = 'rgba(255,255,255,0.1)';
                        tile.style.borderWidth = '3px';
                        tile.style.boxShadow = 'none';
                      }, 300);
                      
                      // Check if correct so far
                      if (sequence[playerSequence.length - 1] !== index) {
                        // Wrong!
                        taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚ùå Wrong sequence!</h2></div>`;
                        setTimeout(() => closeTaskModal(), 2000);
                        return;
                      }
                      
                      // Check if complete
                      if (playerSequence.length === sequence.length) {
                        // Correct!
                        round++;
                        if (round > maxRounds) {
                          taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>üéâ Perfect!</h2><p>All 3 rounds completed!</p></div>`;
                          setTimeout(() => {
                            updateMainScore(3000);
                            markTaskComplete();
                          }, 1500);
                        } else {
                          taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚úÖ Round ${round - 1} complete!</h2></div>`;
                          setTimeout(() => playRound(), 1500);
                        }
                      }
                    };
                  });
                };
              };
              
              playRound();
            };
          }

          // 3. Film Title Scrambler - Type to unscramble letters in each word
          // Global state for tracking films
          let filmScramblerState = {
            currentFilm: null,
            previousFilm: null,
            streak: 0,
            startTime: null
          };

          async function setupFilmTitleScramblerTask() {
            taskModalTitle.textContent = "Film Title Scrambler üé¨";
            
            // Helper function to extract clean title from video filename
            function getVideoTitle(videoIndex) {
              if (videoFiles.length === 0 || videoIndex < 0 || videoIndex >= videoFiles.length) {
                return null;
              }
              const filename = videoFiles[videoIndex].name;
              // Remove file extension
              let title = filename.replace(/\.[^/.]+$/, "");
              // Replace underscores, hyphens, and dots with spaces
              title = title.replace(/[_\-\.]+/g, " ");
              // Capitalize first letter of each word
              title = title.split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ')
                .trim();
              return title;
            }
            
            // Helper function to scramble letters in a word
            function scrambleWord(word) {
              const letters = word.split('');
              // Fisher-Yates shuffle to ensure proper scrambling
              for (let i = letters.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [letters[i], letters[j]] = [letters[j], letters[i]];
              }
              // Make sure it's actually different from original (for words > 2 letters)
              const scrambled = letters.join('');
              return scrambled === word && word.length > 2 ? scrambleWord(word) : scrambled;
            }
            
            // Get current and previous video titles
            let currentFilm = null;
            let previousFilm = null;
            
            if (videoFiles.length > 0 && currentVideoIndex >= 0) {
              // Get current video title
              currentFilm = getVideoTitle(currentVideoIndex);
              
              // Get previous video title (wrap around if at start)
              const previousIndex = (currentVideoIndex - 1 + videoFiles.length) % videoFiles.length;
              previousFilm = getVideoTitle(previousIndex);
            }
            
            // If no videos available, show error
            if (!currentFilm) {
              taskModalBody.innerHTML = `
                <div style="text-align: center; padding: 2rem;">
                  <h3>‚ùå No Videos Available</h3>
                  <p>Please upload videos to play this challenge.</p>
                </div>
              `;
              return;
            }
            
            // Update state
            filmScramblerState.previousFilm = filmScramblerState.currentFilm;
            filmScramblerState.currentFilm = currentFilm;
            filmScramblerState.startTime = Date.now();
            
            // Prepare current and previous film data
            const films = [];
            if (filmScramblerState.previousFilm && previousFilm) {
              films.push({
                title: previousFilm,
                label: "Previous Video",
                color: "rgba(155, 89, 182, 0.3)"
              });
            }
            films.push({
              title: currentFilm,
              label: "Current Video (Now Playing)",
              color: "rgba(52, 152, 219, 0.3)"
            });
            
            // Build UI with word-by-word inputs
            let html = `
              <div style="text-align: center; margin-bottom: 1rem;">
                <h3>Unscramble the letters in each word!</h3>
                <p style="color: #aaa; font-size: 0.9rem;">Type the correct letters for each scrambled word</p>
                ${filmScramblerState.streak > 0 ? `<p style="color: #f39c12; font-size: 1.1rem; font-weight: bold;">üî• Streak: ${filmScramblerState.streak}</p>` : ''}
              </div>
            `;
            
            // Create sections for each film
            const filmData = [];
            films.forEach((film, filmIndex) => {
              const words = film.title.split(' ');
              const scrambledWords = words.map(word => scrambleWord(word));
              
              filmData.push({
                title: film.title,
                words: words,
                scrambledWords: scrambledWords,
                userInputs: Array(words.length).fill(''),
                completed: Array(words.length).fill(false)
              });
              
              html += `
                <div style="background: ${film.color}; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;" data-film-index="${filmIndex}">
                  <h4 style="margin-bottom: 1rem; color: #fff;">${film.label}</h4>
                  <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center;">
                    ${scrambledWords.map((scrambled, wordIndex) => `
                      <div style="display: flex; flex-direction: column; align-items: center; gap: 0.3rem;">
                        <div style="
                          background: rgba(0,0,0,0.4);
                          padding: 0.5rem 1rem;
                          border-radius: 4px;
                          font-family: monospace;
                          font-size: 1.2rem;
                          letter-spacing: 2px;
                          color: #ecf0f1;
                          min-width: 80px;
                          text-align: center;
                        ">${scrambled}</div>
                        <input
                          type="text"
                          class="word-input"
                          data-film-index="${filmIndex}"
                          data-word-index="${wordIndex}"
                          data-correct-word="${words[wordIndex]}"
                          maxlength="${words[wordIndex].length}"
                          placeholder="${'_'.repeat(words[wordIndex].length)}"
                          style="
                            width: ${Math.max(80, words[wordIndex].length * 15)}px;
                            padding: 0.5rem;
                            font-size: 1rem;
                            text-align: center;
                            border: 2px solid #555;
                            border-radius: 4px;
                            background: rgba(255,255,255,0.1);
                            color: #fff;
                            text-transform: uppercase;
                          "
                        />
                        <div class="feedback" data-film-index="${filmIndex}" data-word-index="${wordIndex}" style="min-height: 20px; font-size: 0.9rem;"></div>
                      </div>
                    `).join('')}
                  </div>
                </div>
              `;
            });
            
            html += `
              <div style="text-align: center; margin-top: 1rem;">
                <button id="check-all-btn" class="modal-action-btn">Check All Words</button>
                <button id="submit-final-btn" class="modal-action-btn" style="display: none; background: #27ae60;">Submit Final Answer</button>
              </div>
              <div id="overall-feedback" style="margin-top: 1rem; text-align: center; font-size: 1.1rem;"></div>
            `;
            
            taskModalBody.innerHTML = html;
            
            // Store film data for validation
            const allFilmData = filmData;
            
            // Add input event listeners for real-time feedback
            const inputs = document.querySelectorAll('.word-input');
            inputs.forEach(input => {
              input.addEventListener('input', (e) => {
                const filmIndex = parseInt(e.target.dataset.filmIndex);
                const wordIndex = parseInt(e.target.dataset.wordIndex);
                const correctWord = e.target.dataset.correctWord;
                const userInput = e.target.value.toUpperCase();
                const feedback = document.querySelector(`.feedback[data-film-index="${filmIndex}"][data-word-index="${wordIndex}"]`);
                
                // Update stored input
                allFilmData[filmIndex].userInputs[wordIndex] = userInput;
                
                // Provide letter-by-letter feedback
                if (userInput.length === 0) {
                  feedback.textContent = '';
                  e.target.style.borderColor = '#555';
                } else if (userInput === correctWord.toUpperCase()) {
                  feedback.textContent = '‚úì Correct!';
                  feedback.style.color = '#2ecc71';
                  e.target.style.borderColor = '#2ecc71';
                  allFilmData[filmIndex].completed[wordIndex] = true;
                } else {
                  // Show partial progress
                  let correctCount = 0;
                  for (let i = 0; i < Math.min(userInput.length, correctWord.length); i++) {
                    if (userInput[i] === correctWord[i].toUpperCase()) {
                      correctCount++;
                    }
                  }
                  feedback.textContent = `${correctCount}/${correctWord.length} letters correct`;
                  feedback.style.color = '#f39c12';
                  e.target.style.borderColor = '#f39c12';
                  allFilmData[filmIndex].completed[wordIndex] = false;
                }
              });
              
              // Auto-advance to next input on completion
              input.addEventListener('keyup', (e) => {
                const correctWord = e.target.dataset.correctWord;
                if (e.target.value.toUpperCase() === correctWord.toUpperCase() && e.target.value.length === correctWord.length) {
                  // Find next empty input
                  const allInputs = Array.from(inputs);
                  const currentIndex = allInputs.indexOf(e.target);
                  for (let i = currentIndex + 1; i < allInputs.length; i++) {
                    if (allInputs[i].value === '') {
                      allInputs[i].focus();
                      break;
                    }
                  }
                }
              });
            });
            
            // Check all words button
            document.getElementById('check-all-btn').onclick = () => {
              let allCorrect = true;
              let totalWords = 0;
              let correctWords = 0;
              
              allFilmData.forEach((filmData, filmIndex) => {
                filmData.words.forEach((word, wordIndex) => {
                  totalWords++;
                  const userInput = filmData.userInputs[wordIndex].toUpperCase();
                  const isCorrect = userInput === word.toUpperCase();
                  if (isCorrect) {
                    correctWords++;
                  } else {
                    allCorrect = false;
                  }
                });
              });
              
              const overallFeedback = document.getElementById('overall-feedback');
              if (allCorrect) {
                const timeElapsed = ((Date.now() - filmScramblerState.startTime) / 1000).toFixed(1);
                filmScramblerState.streak++;
                
                let bonusPoints = 0;
                if (timeElapsed < 10) {
                  bonusPoints = 1000;
                  overallFeedback.innerHTML = `<p style="color: #2ecc71; font-weight: bold;">üéâ Perfect! All ${totalWords} words correct in ${timeElapsed}s!</p><p style="color: #f39c12;">‚ö° Speed bonus: +${bonusPoints} points!</p>`;
                } else if (timeElapsed < 20) {
                  bonusPoints = 500;
                  overallFeedback.innerHTML = `<p style="color: #2ecc71; font-weight: bold;">üéâ Perfect! All ${totalWords} words correct in ${timeElapsed}s!</p><p style="color: #f39c12;">‚ö° Speed bonus: +${bonusPoints} points!</p>`;
                } else {
                  overallFeedback.innerHTML = `<p style="color: #2ecc71; font-weight: bold;">üéâ Perfect! All ${totalWords} words correct in ${timeElapsed}s!</p>`;
                }
                
                document.getElementById('check-all-btn').style.display = 'none';
                document.getElementById('submit-final-btn').style.display = 'inline-block';
                
                document.getElementById('submit-final-btn').onclick = () => {
                  const totalScore = 2000 + bonusPoints + (filmScramblerState.streak > 1 ? (filmScramblerState.streak - 1) * 500 : 0);
                  taskModalBody.innerHTML = `
                    <div style="text-align: center; padding: 2rem;">
                      <h2>üéâ Excellent Work!</h2>
                      ${filmScramblerState.streak > 1 ? `<p style="color: #f39c12; font-size: 1.3rem; font-weight: bold;">üî• ${filmScramblerState.streak} Win Streak! +${(filmScramblerState.streak - 1) * 500} bonus</p>` : ''}
                      <p style="font-size: 1.2rem; margin-top: 1rem;">Total Score: ${totalScore} points</p>
                    </div>
                  `;
                  setTimeout(() => {
                    updateMainScore(totalScore);
                    markTaskComplete();
                  }, 1500);
                };
              } else {
                filmScramblerState.streak = 0;
                overallFeedback.innerHTML = `<p style="color: #e74c3c;">üìù ${correctWords}/${totalWords} words correct. Keep trying!</p>`;
              }
            };
            
            // Focus first input
            if (inputs.length > 0) {
              inputs[0].focus();
            }
          }

          // 4. Higher or Lower Views - Guess which video has more views
          async function setupHigherLowerViewsTask() {
            taskModalTitle.textContent = "Higher or Lower üìä";
            
            // Check if we have uploaded film data
            const savedFilmData = JSON.parse(localStorage.getItem('filmViewsData') || '[]');
            
            let filmData = [];
            if (savedFilmData.length >= 2) {
              // Use uploaded film data
              filmData = savedFilmData;
            } else if (videoFiles.length >= 2) {
              // Fallback to video files with random view counts
              filmData = videoFiles.map((file, i) => ({
                title: file.name.replace(/\.[^/.]+$/, ''), // Remove extension
                views: Math.floor(Math.random() * 10000) + 100
              }));
            } else {
              taskModalBody.innerHTML = `<p class="text-red-500">You need at least 2 videos or uploaded film data for this challenge.</p>`;
              return;
            }
            
            let correctAnswers = 0;
            let wrongAnswers = 0;
            const maxRounds = 5;
            
            const playRound = () => {
              if (wrongAnswers >= 1) {
                taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚ùå You Lost!</h2><p>One wrong answer and you're out!</p></div>`;
                setTimeout(() => closeTaskModal(), 2000);
                return;
              }
              
              if (correctAnswers >= maxRounds) {
                taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>üéâ You Win!</h2><p>5 correct in a row!</p></div>`;
                setTimeout(() => {
                  updateMainScore(3000);
                  markTaskComplete();
                }, 1500);
                return;
              }
              
              // Pick 2 random films
              const indices = [...Array(filmData.length).keys()];
              const shuffled = indices.sort(() => 0.5 - Math.random());
              const film1Index = shuffled[0];
              const film2Index = shuffled[1];
              
              const film1 = filmData[film1Index];
              const film2 = filmData[film2Index];
              
              taskModalTitle.textContent = `Round ${correctAnswers + 1}/${maxRounds}`;
              taskModalBody.innerHTML = `
                <div style="text-align: center;">
                  <div style="margin-bottom: 2rem;">
                    <h3>${film1.title}</h3>
                    <p style="font-size: 2rem; color: #3498db;">${film1.views.toLocaleString()} views</p>
                  </div>
                  <div style="font-size: 2rem; margin: 1rem 0;">üÜö</div>
                  <div style="margin-bottom: 2rem;">
                    <h3>${film2.title}</h3>
                    <p style="font-size: 2rem;">??? views</p>
                  </div>
                  <div style="display: flex; gap: 1rem; justify-content: center;">
                    <button id="guess-higher" class="modal-action-btn">üìà Higher</button>
                    <button id="guess-lower" class="modal-action-btn">üìâ Lower</button>
                  </div>
                </div>
              `;
              
              document.getElementById('guess-higher').onclick = () => checkAnswer(film2.views > film1.views, film2.views);
              document.getElementById('guess-lower').onclick = () => checkAnswer(film2.views < film1.views, film2.views);
              
              const checkAnswer = (isCorrect, actualViews) => {
                if (isCorrect) {
                  correctAnswers++;
                  taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚úÖ Correct!</h2><p>${actualViews.toLocaleString()} views</p></div>`;
                  setTimeout(() => playRound(), 1500);
                } else {
                  wrongAnswers++;
                  taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚ùå Wrong!</h2><p>It was ${actualViews.toLocaleString()} views</p></div>`;
                  setTimeout(() => playRound(), 1500);
                }
              };
            };
            
            taskModalBody.innerHTML = `
              <h3>Rules:</h3>
              <ul style="list-style: disc; margin-left: 2rem; margin-top: 1rem;">
                <li>You'll see 2 ${savedFilmData.length >= 2 ? 'film titles' : 'video titles'}</li>
                <li>One shows its view count</li>
                <li>Guess if the other has Higher or Lower views</li>
                <li>Get 5 correct in a row</li>
                <li>One wrong answer = game over!</li>
              </ul>
              <button id="start-challenge-btn" class="modal-action-btn">Start Game</button>
            `;
            
            document.getElementById('start-challenge-btn').onclick = () => playRound();
          }

          // 5. Icon Click Hunt - Click correct icon 15 times in 1 minute
          async function setupIconClickHuntTask() {
            taskModalTitle.textContent = "Icon Click Hunt üéØ";
            
            // For this demo, we'll use emojis instead of image files
            const correctIcon = '‚úÖ';
            const wrongIcons = ['‚ùå', '‚õî', 'üö´', '‚ùó'];
            
            taskModalBody.innerHTML = `
              <h3>Click the correct icon!</h3>
              <p>Find and click <span style="font-size: 2rem;">${correctIcon}</span> 15 times</p>
              <p>Time limit: 60 seconds</p>
              <p style="color: #e74c3c;">Wrong click = -1 point</p>
              <button id="start-challenge-btn" class="modal-action-btn">Start Hunt</button>
            `;
            
            parseEmojis(taskModalBody);

            document.getElementById('start-challenge-btn').onclick = () => {
              let correctClicks = 0;
              let timeLeft = 60;
              let gameOver = false;
              
              taskModalOverlay.style.pointerEvents = 'none';
              
              const gameOverlay = document.createElement('div');
              gameOverlay.id = 'icon-hunt-overlay';
              gameOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                z-index: 250;
                pointer-events: none;
              `;
              
              const infoPanel = document.createElement('div');
              infoPanel.style.cssText = `
                position: absolute;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0,0,0,0.8);
                padding: 1rem 2rem;
                border-radius: 8px;
                z-index: 10;
                pointer-events: none;
              `;
              infoPanel.innerHTML = `
                <div style="display: flex; gap: 2rem; align-items: center;">
                  <div id="hunt-score" style="font-size: 1.5rem; color: #10b981;">Score: 0/15</div>
                  <div id="hunt-timer" style="font-size: 1.5rem; color: #f59e0b;">Time: 60s</div>
                </div>
              `;
              gameOverlay.appendChild(infoPanel);
              document.body.appendChild(gameOverlay);
              
              const spawnIcon = () => {
                if (gameOver) return;
                
                const isCorrect = Math.random() < 0.4; // 40% chance of correct icon
                const icon = isCorrect ? correctIcon : wrongIcons[Math.floor(Math.random() * wrongIcons.length)];
                
                const iconEl = document.createElement('div');
                iconEl.textContent = icon;
                iconEl.style.cssText = `
                  position: absolute;
                  font-size: 3rem;
                  cursor: pointer;
                  pointer-events: auto;
                  top: ${Math.random() * 70 + 15}%;
                  left: ${Math.random() * 80 + 10}%;
                  transition: transform 0.1s;
                `;
                
                iconEl.onclick = () => {
                  if (gameOver) return;
                  
                  if (isCorrect) {
                    correctClicks++;
                    document.getElementById('hunt-score').textContent = `Score: ${correctClicks}/15`;
                    iconEl.style.transform = 'scale(1.5)';
                    iconEl.style.opacity = '0';
                    
                    if (correctClicks >= 15) {
                      gameOver = true;
                      clearInterval(spawnInterval);
                      clearInterval(timerInterval);
                      gameOverlay.remove();
                      taskModalOverlay.style.pointerEvents = 'all';
                      taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>üéâ Success!</h2><p>15 correct clicks!</p></div>`;
                      setTimeout(() => {
                        updateMainScore(3000);
                        markTaskComplete();
                      }, 1500);
                    }
                  } else {
                    correctClicks = Math.max(0, correctClicks - 1);
                    document.getElementById('hunt-score').textContent = `Score: ${correctClicks}/15`;
                    iconEl.style.background = 'red';
                    iconEl.style.borderRadius = '50%';
                  }
                  
                  setTimeout(() => iconEl.remove(), 200);
                };
                
                gameOverlay.appendChild(iconEl);
                parseEmojis(iconEl);
                
                setTimeout(() => {
                  if (iconEl.parentNode && !gameOver) {
                    iconEl.remove();
                  }
                }, 2000);
              };
              
              const spawnInterval = setInterval(() => spawnIcon(), 800);
              currentTimers.push(spawnInterval);
              
              const timerInterval = setInterval(() => {
                timeLeft--;
                document.getElementById('hunt-timer').textContent = `Time: ${timeLeft}s`;
                
                if (timeLeft <= 0 && !gameOver) {
                  gameOver = true;
                  clearInterval(spawnInterval);
                  clearInterval(timerInterval);
                  gameOverlay.remove();
                  taskModalOverlay.style.pointerEvents = 'all';
                  taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚è∞ Time's Up!</h2><p>Only ${correctClicks}/15</p></div>`;
                  setTimeout(() => closeTaskModal(), 2000);
                }
              }, 1000);
              
              currentTimers.push(timerInterval);
            };
          }

          // 6. Trivia Speed Quiz - Answer 5 questions correctly in 45 seconds
          async function setupTriviaSpeedQuizTask() {
            taskModalTitle.textContent = "Trivia Speed Quiz ‚ö°";
            
            taskModalBody.innerHTML = `<h3>Loading questions...</h3><p>Please wait...</p>`;
            
            const questions = await fetchTriviaQuestions(10, null, 'medium');
            
            if (!questions) {
              taskModalBody.innerHTML = `<p class="text-red-500">Failed to load questions. Please try again.</p>`;
              return;
            }
            
            let correctAnswers = 0;
            let currentQ = 0;
            let timeLeft = 45;
            let quizOver = false;
            
            taskModalBody.innerHTML = `
              <h3>Answer 5 questions correctly!</h3>
              <p>Time limit: 45 seconds</p>
              <button id="start-challenge-btn" class="modal-action-btn">Start Quiz</button>
            `;
            
            document.getElementById('start-challenge-btn').onclick = () => {
              const timerInterval = setInterval(() => {
                timeLeft--;
                const timerEl = document.getElementById('quiz-timer');
                if (timerEl) timerEl.innerHTML = `Time: ${timeLeft}s`;
                
                if (timeLeft <= 0 && !quizOver) {
                  quizOver = true;
                  clearInterval(timerInterval);
                  taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚è∞ Time's Up!</h2><p>${correctAnswers}/5 correct</p><p>You needed 5 correct answers to win.</p></div>`;
                  setTimeout(() => closeTaskModal(), 2000);
                }
              }, 1000);
              
              currentTimers.push(timerInterval);
              modalTimer = timerInterval;
              
              const renderQuestion = () => {
                if (quizOver) return;
                
                if (correctAnswers >= 5) {
                  quizOver = true;
                  clearInterval(timerInterval);
                  taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>üéâ Success!</h2><p>5 correct in ${45 - timeLeft}s</p></div>`;
                  setTimeout(() => {
                    updateMainScore(3000);
                    markTaskComplete();
                  }, 1500);
                  return;
                }
                
                if (currentQ >= questions.length) {
                  // Need more questions but didn't get 5 correct
                  quizOver = true;
                  clearInterval(timerInterval);
                  taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>üìù Not enough!</h2><p>Only ${correctAnswers}/5 correct</p></div>`;
                  setTimeout(() => closeTaskModal(), 2000);
                  return;
                }
                
                const q = questions[currentQ];
                taskModalBody.innerHTML = `
                  <div id="quiz-timer" style="text-align: center; font-size: 1.5rem; margin-bottom: 1rem; font-weight: bold; color: #f59e0b;">Time: ${timeLeft}s</div>
                  <div style="text-align: center; font-size: 1.2rem; margin-bottom: 0.5rem; font-weight: bold; color: #10b981;">Score: ${correctAnswers}/5</div>
                  <p class="text-xl mb-4">${q.question}</p>
                  <div class="task-option-grid">
                    ${q.options.map((opt, i) => `<button class="task-option-btn" data-index="${i}">${opt}</button>`).join('')}
                  </div>
                `;
                
                document.querySelectorAll('.task-option-btn').forEach(btn => {
                  btn.onclick = () => {
                    if (quizOver) return;
                    
                    const selectedIndex = parseInt(btn.dataset.index);
                    const correctIndex = q.correctAnswerIndex;
                    
                    if (selectedIndex === correctIndex) {
                      correctAnswers++;
                      btn.style.background = '#27ae60';
                    } else {
                      btn.style.background = '#e74c3c';
                      document.querySelectorAll('.task-option-btn')[correctIndex].style.background = '#27ae60';
                    }
                    
                    setTimeout(() => {
                      currentQ++;
                      renderQuestion();
                    }, 800);
                  };
                });
              };
              
              renderQuestion();
            };
          }

          // 7. Paint Splatter - Cover 90%+ of background video in 30 seconds
          async function setupPaintSplatterTask() {
            taskModalTitle.textContent = "Paint Splatter üé®";
            
            taskModalBody.innerHTML = `
              <h3>Cover the video with paint!</h3>
              <p>Click/tap to splatter white paint</p>
              <p>Goal: Cover 90% of the video in 30 seconds</p>
              <button id="start-challenge-btn" class="modal-action-btn">Start Painting</button>
            `;
            
            document.getElementById('start-challenge-btn').onclick = () => {
              // Create canvas overlay
              taskModalOverlay.style.pointerEvents = 'none';
              
              const canvas = document.createElement('canvas');
              canvas.id = 'paint-canvas';
              canvas.width = window.innerWidth;
              canvas.height = window.innerHeight;
              canvas.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                z-index: 250;
                cursor: crosshair;
                pointer-events: auto;
              `;
              document.body.appendChild(canvas);
              
              const ctx = canvas.getContext('2d');
              let coverage = 0;
              let timeLeft = 30;
              let gameOver = false;
              
              // Info panel
              const infoPanel = document.createElement('div');
              infoPanel.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0,0,0,0.8);
                padding: 1rem 2rem;
                border-radius: 8px;
                z-index: 260;
                pointer-events: none;
              `;
              infoPanel.innerHTML = `
                <div style="display: flex; gap: 2rem;">
                  <div id="paint-coverage" style="font-size: 1.5rem; color: #10b981;">Coverage: 0%</div>
                  <div id="paint-timer" style="font-size: 1.5rem; color: #f59e0b;">Time: 30s</div>
                </div>
              `;
              document.body.appendChild(infoPanel);
              
              const splatter = (x, y) => {
                const radius = 40 + Math.random() * 30;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Drips
                for (let i = 0; i < 3; i++) {
                  const dripX = x + (Math.random() - 0.5) * radius;
                  const dripHeight = Math.random() * 50;
                  ctx.fillRect(dripX, y + radius, 3, dripHeight);
                }
                
                // Calculate coverage
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let paintedPixels = 0;
                for (let i = 3; i < imageData.data.length; i += 4) {
                  if (imageData.data[i] > 0) paintedPixels++;
                }
                coverage = (paintedPixels / (canvas.width * canvas.height)) * 100;
                document.getElementById('paint-coverage').textContent = `Coverage: ${Math.floor(coverage)}%`;
                
                if (coverage >= 90 && !gameOver) {
                  gameOver = true;
                  clearInterval(timerInterval);
                  canvas.remove();
                  infoPanel.remove();
                  taskModalOverlay.style.pointerEvents = 'all';
                  taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>üéâ Success!</h2><p>${Math.floor(coverage)}% covered!</p></div>`;
                  setTimeout(() => {
                    updateMainScore(2500);
                    markTaskComplete();
                  }, 1500);
                }
              };
              
              canvas.addEventListener('click', (e) => {
                if (!gameOver) splatter(e.clientX, e.clientY);
              });
              
              const timerInterval = setInterval(() => {
                timeLeft--;
                document.getElementById('paint-timer').textContent = `Time: ${timeLeft}s`;
                
                if (timeLeft <= 0 && !gameOver) {
                  gameOver = true;
                  clearInterval(timerInterval);
                  canvas.remove();
                  infoPanel.remove();
                  taskModalOverlay.style.pointerEvents = 'all';
                  taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚è∞ Time's Up!</h2><p>Only ${Math.floor(coverage)}% covered</p></div>`;
                  setTimeout(() => closeTaskModal(), 2000);
                }
              }, 1000);
              
              currentTimers.push(timerInterval);
            };
          }

          // 8. Timestamp Match - Click when video returns to same timestamp
          async function setupTimestampMatchTask() {
            taskModalTitle.textContent = "Timestamp Match ‚è±Ô∏è";
            
            if (videoFiles.length < 1) {
              taskModalBody.innerHTML = `<p class="text-red-500">You need at least 1 video for this challenge.</p>`;
              return;
            }
            
            taskModalBody.innerHTML = `
              <h3>Remember the timestamp!</h3>
              <p>The video will show a moment, then jump around.</p>
              <p>Click when it returns to the SAME moment!</p>
              <button id="start-challenge-btn" class="modal-action-btn">Start Challenge</button>
            `;
            
            document.getElementById('start-challenge-btn').onclick = async () => {
              const videoIndex = Math.floor(Math.random() * videoFiles.length);
              const file = videoFiles[videoIndex];
              const url = createTrackedObjectURL(file);
              
              // Create video element
              const tempVideo = document.createElement('video');
              tempVideo.src = url;
              tempVideo.muted = true;
              
              await new Promise(resolve => {
                tempVideo.onloadedmetadata = () => resolve();
              });
              
              // Check if video is long enough (at least 20 minutes to ensure 10+ minute gap is possible)
              if (tempVideo.duration < 1200) {
                taskModalBody.innerHTML = `<p class="text-red-500">Video must be at least 20 minutes long for this challenge to ensure clips are sufficiently far apart.</p>`;
                return;
              }
              
              const targetTime = Math.random() * (tempVideo.duration - 10);
              
              taskModalBody.innerHTML = `
                <div style="width: 100%; max-width: 500px; margin: 0 auto;">
                  <video id="timestamp-video" style="width: 100%; height: auto;" muted playsinline></video>
                </div>
                <p id="timestamp-instruction" style="margin-top: 1rem; font-size: 1.2rem;">Watch this moment...</p>
                <button id="timestamp-click-btn" class="modal-action-btn" disabled style="margin-top: 1rem;">Click when it matches!</button>
              `;
              
              const player = document.getElementById('timestamp-video');
              player.src = url;
              
              await new Promise(resolve => {
                player.onloadedmetadata = () => resolve();
              });
              
              // Show target timestamp for 2 seconds
              player.currentTime = targetTime;
              await player.play();
              await new Promise(resolve => setTimeout(resolve, 2000));
              player.pause();
              
              document.getElementById('timestamp-instruction').textContent = 'Video is jumping around... Click when it matches!';
              document.getElementById('timestamp-click-btn').disabled = false;
              
              let gameOver = false;
              let currentJumpTime = 0;
              
              // Jump around every 2 seconds, ensuring clips are at least 10 minutes apart
              const jumpInterval = setInterval(() => {
                if (gameOver) {
                  clearInterval(jumpInterval);
                  return;
                }
                
                // Generate a jump time that is at least 600 seconds (10 minutes) away from target
                let newJumpTime;
                do {
                  newJumpTime = Math.random() * tempVideo.duration;
                } while (Math.abs(newJumpTime - targetTime) < 600);
                
                currentJumpTime = newJumpTime;
                player.currentTime = currentJumpTime;
                player.play();
              }, 2000);
              
              currentTimers.push(jumpInterval);
              
              document.getElementById('timestamp-click-btn').onclick = () => {
                if (gameOver) return;
                gameOver = true;
                clearInterval(jumpInterval);
                player.pause();
                
                // Check if close to target (within 0.5 seconds)
                const diff = Math.abs(currentJumpTime - targetTime);
                
                if (diff <= 0.5) {
                  taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>üéâ Perfect Match!</h2><p>Within 0.5 seconds!</p></div>`;
                  setTimeout(() => {
                    updateMainScore(3000);
                    markTaskComplete();
                  }, 1500);
                } else {
                  taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚ùå Not quite!</h2><p>You were ${diff.toFixed(1)}s off</p></div>`;
                  setTimeout(() => closeTaskModal(), 2000);
                }
              };
            };
          }

          // 9. Video Quarter Puzzle - Find the common video in 4 quarters
          async function setupVideoQuarterPuzzleTask() {
            taskModalTitle.textContent = "Video Quarter Puzzle üß©";
            
            if (videoFiles.length < 8) {
              taskModalBody.innerHTML = `<p class="text-red-500">You need at least 8 videos for this challenge.</p>`;
              return;
            }
            
            taskModalBody.innerHTML = `
              <h3>Find the common video!</h3>
              <p>4 quarters will play different 5-second clips</p>
              <p>Only ONE video appears in ALL quarters</p>
              <p>Click each quarter to lock it when you see the common video</p>
              <p>60 second time limit!</p>
              <button id="start-challenge-btn" class="modal-action-btn">Start Puzzle</button>
            `;
            
            document.getElementById('start-challenge-btn').onclick = () => {
              // Pick 7-8 random videos
              const shuffled = [...videoFiles.keys()].sort(() => 0.5 - Math.random());
              const videoPool = shuffled.slice(0, 8);
              
              // Pick one to be the "correct" answer that appears in all quarters
              const correctVideoIndex = videoPool[0];
              
              // For each quarter, create a sequence that includes the correct video
              const quarters = [];
              for (let q = 0; q < 4; q++) {
                const quarterVideos = [correctVideoIndex];
                // Add 2-3 random others
                const others = videoPool.filter(v => v !== correctVideoIndex).sort(() => 0.5 - Math.random()).slice(0, 3);
                quarterVideos.push(...others);
                quarterVideos.sort(() => 0.5 - Math.random());
                quarters.push(quarterVideos);
              }
              
              taskModalOverlay.style.pointerEvents = 'none';
              
              // Create 2x2 grid overlay
              const gridOverlay = document.createElement('div');
              gridOverlay.id = 'quarter-grid';
              gridOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                z-index: 250;
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: 1fr 1fr;
                gap: 2px;
                background: #000;
              `;
              
              for (let q = 0; q < 4; q++) {
                const quarterDiv = document.createElement('div');
                quarterDiv.style.cssText = `
                  position: relative;
                  background: #222;
                  cursor: pointer;
                  overflow: hidden;
                `;
                quarterDiv.dataset.quarter = q;
                
                const video = document.createElement('video');
                video.style.cssText = `
                  width: 100%;
                  height: 100%;
                  object-fit: cover;
                `;
                video.muted = true;
                video.loop = false;
                video.playsinline = true;
                
                const statusLabel = document.createElement('div');
                statusLabel.style.cssText = `
                  position: absolute;
                  top: 10px;
                  left: 10px;
                  background: rgba(0,0,0,0.7);
                  padding: 0.5rem 1rem;
                  border-radius: 4px;
                  font-weight: bold;
                  z-index: 10;
                `;
                statusLabel.textContent = `Q${q + 1}: Cycling`;
                
                quarterDiv.appendChild(video);
                quarterDiv.appendChild(statusLabel);
                gridOverlay.appendChild(quarterDiv);
              }
              
              document.body.appendChild(gridOverlay);
              
              // Timer
              const timerDiv = document.createElement('div');
              timerDiv.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0,0,0,0.8);
                padding: 1rem 2rem;
                border-radius: 8px;
                z-index: 260;
                font-size: 1.5rem;
                color: #f59e0b;
              `;
              timerDiv.id = 'quarter-timer';
              timerDiv.textContent = 'Time: 60s';
              document.body.appendChild(timerDiv);
              
              let timeLeft = 60;
              let gameOver = false;
              const lockedQuarters = new Set();
              
              // Cycle videos in each quarter
              const cycleVideos = async () => {
                while (!gameOver) {
                  for (let q = 0; q < 4; q++) {
                    if (lockedQuarters.has(q)) continue;
                    
                    const quarterDiv = document.querySelector(`[data-quarter="${q}"]`);
                    const video = quarterDiv.querySelector('video');
                    const videoIndex = quarters[q][Math.floor(Math.random() * quarters[q].length)];
                    const file = videoFiles[videoIndex];
                    
                    // Revoke previous URL if exists
                    if (video.src && video.src.startsWith('blob:')) {
                      revokeTrackedObjectURL(video.src);
                    }
                    
                    video.src = createTrackedObjectURL(file);
                    await new Promise(resolve => {
                      video.onloadedmetadata = () => {
                        video.currentTime = Math.random() * Math.max(0, video.duration - 5);
                        video.play();
                        setTimeout(resolve, 5000);
                      };
                    });
                  }
                }
              };
              
              cycleVideos();
              
              // Click to lock quarter
              document.querySelectorAll('[data-quarter]').forEach(div => {
                div.onclick = () => {
                  const q = parseInt(div.dataset.quarter);
                  if (lockedQuarters.has(q) || gameOver) return;
                  
                  lockedQuarters.add(q);
                  div.style.border = '5px solid #10b981';
                  div.querySelector('div').textContent = `Q${q + 1}: LOCKED ‚úì`;
                  div.querySelector('div').style.color = '#10b981';
                  
                  // Check if all locked
                  if (lockedQuarters.size === 4) {
                    gameOver = true;
                    clearInterval(timerInterval);
                    
                    // Check if all locked on correct video (simplified - just give success)
                    gridOverlay.remove();
                    timerDiv.remove();
                    taskModalOverlay.style.pointerEvents = 'all';
                    taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>üéâ Puzzle Complete!</h2><p>You locked all quarters!</p></div>`;
                    setTimeout(() => {
                      updateMainScore(3000);
                      markTaskComplete();
                    }, 1500);
                  }
                };
              });
              
              const timerInterval = setInterval(() => {
                timeLeft--;
                timerDiv.textContent = `Time: ${timeLeft}s`;
                
                if (timeLeft <= 0 && !gameOver) {
                  gameOver = true;
                  clearInterval(timerInterval);
                  gridOverlay.remove();
                  timerDiv.remove();
                  taskModalOverlay.style.pointerEvents = 'all';
                  taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>‚è∞ Time's Up!</h2><p>Only ${lockedQuarters.size}/4 locked</p></div>`;
                  setTimeout(() => closeTaskModal(), 2000);
                }
              }, 1000);
              
              currentTimers.push(timerInterval);
            };
          }

          // 10. Creative Challenge - Manual upload with ChatGPT link and winner buttons
          async function setupCreativeChallengeTask() {
            taskModalTitle.textContent = "Creative Challenge üí°";
            
            // Check if there are any custom challenges stored
            const customChallenges = JSON.parse(localStorage.getItem('customCreativeChallenges') || '[]');
            
            let challengeText = '';
            if (customChallenges.length > 0) {
              challengeText = customChallenges[Math.floor(Math.random() * customChallenges.length)];
            } else {
              challengeText = "Tell us your funniest cloud-related story!";
            }
            
            // Get active players with their global indices
            const activePlayers = challengePlayers
              .map((p, globalIdx) => ({ player: p, globalIndex: globalIdx }))
              .filter(item => item.player.active);
            
            taskModalBody.innerHTML = `
              <div style="text-align: center;">
                <h3 style="margin-bottom: 2rem;">Your Challenge:</h3>
                <p style="font-size: 1.3rem; font-style: italic; margin-bottom: 2rem; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 8px;">
                  "${challengeText}"
                </p>
                
                <div style="margin-bottom: 2rem;">
                  <a href="https://chat.openai.com/" target="_blank" rel="noopener noreferrer" class="modal-action-btn" style="display: inline-block; text-decoration: none;">
                    üé§ Open ChatGPT Voice Chat
                  </a>
                </div>
                
                <h3 style="margin-bottom: 1rem;">Who completed it better?</h3>
                <div style="display: flex; gap: 1rem; justify-content: center; margin-bottom: 1rem; flex-wrap: wrap;">
                  ${activePlayers.map(item => {
                    return `<button id="player${item.globalIndex}-win" class="modal-action-btn" style="background: ${item.player.color};">
                      ${item.player.badge} Wins
                    </button>`;
                  }).join('')}
                </div>
                
                <button id="skip-challenge" class="modal-action-btn" style="background: rgba(100,100,100,0.5);">
                  Skip Challenge
                </button>
              </div>
            `;
            
            // Set up winner click handlers
            activePlayers.forEach(item => {
              document.getElementById(`player${item.globalIndex}-win`).onclick = () => {
                currentChallengePlayerIndex = item.globalIndex;
                taskModalBody.innerHTML = `<div style="text-align: center; padding: 2rem;"><h2>üèÜ ${item.player.badge} Wins!</h2><p>They get the next turn!</p></div>`;
                setTimeout(() => {
                  closeTaskModal();
                  // Winner gets next turn, so don't advance
                  renderChallengeHud();
                }, 1500);
              };
            });
            
            document.getElementById('skip-challenge').onclick = () => {
              closeTaskModal();
            };
          }

          // --- Initial Setup ---
          function populateVoices() {
            const voices = speechSynthesis.getVoices();
            storyMakerVoiceSelect.innerHTML = '';
            voices.filter(v => v.lang.startsWith('en')).forEach(voice => {
              const option = document.createElement('option');
              option.textContent = `${voice.name} (${voice.lang})`;
              option.value = voice.voiceURI;
              storyMakerVoiceSelect.appendChild(option);
            });
          }
          populateVoices();
          if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoices;
          }
          document.getElementById('preview-voice-btn').addEventListener('click', () => {
            speak("This is a preview of the selected voice.", storyMakerVoiceSelect.value);
          });

          initChallengeGrid();
          startScoreDecay();
          mainVideo.volume = 0;
          volumeSlider.value = 0;
          
          // Creative Challenges Management
          function loadCreativeChallenges() {
            const challenges = JSON.parse(localStorage.getItem('customCreativeChallenges') || '[]');
            const display = document.getElementById('challenges-display');
            if (challenges.length === 0) {
              display.innerHTML = '<p style="opacity: 0.6; font-style: italic;">No challenges saved yet.</p>';
            } else {
              display.innerHTML = challenges.map((c, i) => `<div style="padding: 0.25rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">${i + 1}. ${c}</div>`).join('');
            }
          }
          
          document.getElementById('save-creative-challenges-btn').addEventListener('click', () => {
            const text = document.getElementById('creative-challenges-input').value.trim();
            if (!text) {
              showToast('Please enter at least one challenge!', 'warning');
              return;
            }
            
            const challenges = text.split('\n').filter(line => line.trim().length > 0);
            localStorage.setItem('customCreativeChallenges', JSON.stringify(challenges));
            loadCreativeChallenges();
            showToast(`Saved ${challenges.length} challenge(s)!`, 'success');
            document.getElementById('creative-challenges-input').value = '';
          });
          
          document.getElementById('clear-challenges-btn').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all saved challenges?')) {
              localStorage.removeItem('customCreativeChallenges');
              loadCreativeChallenges();
            }
          });
          
          loadCreativeChallenges();
          
          // Film Data Uploader Management
          function loadFilmData() {
            const filmData = JSON.parse(localStorage.getItem('filmViewsData') || '[]');
            const display = document.getElementById('film-data-display');
            const count = document.getElementById('film-count');
            count.textContent = filmData.length;
            if (filmData.length === 0) {
              display.innerHTML = '<p style="opacity: 0.6; font-style: italic;">No film data saved yet.</p>';
            } else {
              display.innerHTML = filmData.map((f, i) => 
                `<div style="padding: 0.25rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                  ${i + 1}. ${f.title} - ${f.views.toLocaleString()} views
                </div>`
              ).join('');
            }
          }
          
          document.getElementById('save-film-data-btn').addEventListener('click', () => {
            const text = document.getElementById('film-data-input').value.trim();
            if (!text) {
              showToast('Please enter at least one film entry!', 'warning');
              return;
            }
            
            const lines = text.split('\n').filter(line => line.trim().length > 0);
            const filmData = [];
            let errors = 0;
            
            lines.forEach((line, index) => {
              const parts = line.split('|');
              if (parts.length === 2) {
                const title = parts[0].trim();
                const views = parseInt(parts[1].trim().replace(/,/g, ''));
                if (title && !isNaN(views)) {
                  filmData.push({ title, views });
                } else {
                  errors++;
                }
              } else {
                errors++;
              }
            });
            
            if (filmData.length > 0) {
              localStorage.setItem('filmViewsData', JSON.stringify(filmData));
              loadFilmData();
              showToast(`Saved ${filmData.length} film(s)!${errors > 0 ? ` (${errors} entries had errors and were skipped)` : ''}`, 'success');
              document.getElementById('film-data-input').value = '';
            } else {
              showToast('No valid film data found! Use format: "Title|Views" (one per line)', 'error');
            }
          });
          
          document.getElementById('clear-film-data-btn').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all saved film data?')) {
              localStorage.removeItem('filmViewsData');
              loadFilmData();
            }
          });
          
          loadFilmData();
          
          // Player setup event listeners
          document.getElementById('player1-name-input').addEventListener('input', (e) => {
            challengePlayers[0].name = e.target.value || 'Player 1';
            renderChallengeHud();
          });
          
          document.getElementById('player2-name-input').addEventListener('input', (e) => {
            challengePlayers[1].name = e.target.value || 'Player 2';
            renderChallengeHud();
          });

          document.getElementById('player3-name-input').addEventListener('input', (e) => {
            challengePlayers[2].name = e.target.value || 'Player 3';
            renderChallengeHud();
          });

          document.getElementById('player4-name-input').addEventListener('input', (e) => {
            challengePlayers[3].name = e.target.value || 'Player 4';
            renderChallengeHud();
          });

          document.getElementById('player1-type').addEventListener('change', (e) => {
            challengePlayers[0].type = e.target.value;
          });

          document.getElementById('player2-type').addEventListener('change', (e) => {
            challengePlayers[1].type = e.target.value;
          });

          document.getElementById('player3-type').addEventListener('change', (e) => {
            challengePlayers[2].type = e.target.value;
          });

          document.getElementById('player4-type').addEventListener('change', (e) => {
            challengePlayers[3].type = e.target.value;
          });

          document.getElementById('player2-active').addEventListener('change', (e) => {
            challengePlayers[1].active = e.target.checked;
            renderChallengeHud();
          });

          document.getElementById('player3-active').addEventListener('change', (e) => {
            challengePlayers[2].active = e.target.checked;
            renderChallengeHud();
          });

          document.getElementById('player4-active').addEventListener('change', (e) => {
            challengePlayers[3].active = e.target.checked;
            renderChallengeHud();
          });

          // Global keyboard handler for closing overlays with Cmd+Backspace
          document.addEventListener('keydown', (e) => {
            // Only trigger on Cmd+Backspace (metaKey for Mac, Ctrl for Windows fallback)
            if ((e.metaKey || e.ctrlKey) && e.key === 'Backspace') {
              // Don't interfere with text editing in input fields
              const activeElement = document.activeElement;
              const isInputField = activeElement && (
                activeElement.tagName === 'INPUT' || 
                activeElement.tagName === 'TEXTAREA' || 
                activeElement.isContentEditable
              );
              
              // Find the top-most visible overlay
              const taskModal = document.getElementById('task-modal-overlay');
              const breathingOverlay = document.getElementById('breathingOverlay');
              const countdownOverlay = document.getElementById('countdownOverlay');
              const completionOverlay = document.getElementById('completionOverlay');
              const triviaOverlay = document.getElementById('trivia-game-overlay');
              const movieOverlay = document.getElementById('movie-playback-overlay');
              
              // Check if task modal is visible (highest priority)
              if (taskModal && taskModal.classList.contains('visible')) {
                e.preventDefault();
                closeTaskModal();
                return;
              }
              
              // Check other overlays
              if (triviaOverlay && triviaOverlay.classList.contains('visible')) {
                e.preventDefault();
                triviaOverlay.classList.remove('visible');
                return;
              }
              
              if (movieOverlay && movieOverlay.classList.contains('visible')) {
                e.preventDefault();
                movieOverlay.classList.remove('visible');
                return;
              }
              
              if (breathingOverlay && breathingOverlay.classList.contains('visible')) {
                e.preventDefault();
                breathingOverlay.classList.remove('visible');
                clearAllTimers();
                return;
              }
              
              if (countdownOverlay && countdownOverlay.classList.contains('visible')) {
                e.preventDefault();
                countdownOverlay.classList.remove('visible');
                clearAllTimers();
                return;
              }
              
              if (completionOverlay && completionOverlay.classList.contains('visible')) {
                e.preventDefault();
                completionOverlay.classList.remove('visible');
                return;
              }
            }
          });

          // Swipe gesture handler for closing overlays (right-to-left swipe)
          let touchStartX = 0;
          let touchStartY = 0;
          let touchEndX = 0;
          let touchEndY = 0;
          
          document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
          }, { passive: true });
          
          document.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
          }, { passive: true });
          
          function handleSwipe() {
            const swipeThreshold = 100; // Minimum distance for swipe
            const swipeDistanceX = touchEndX - touchStartX;
            const swipeDistanceY = Math.abs(touchEndY - touchStartY);
            
            // Check for right-to-left swipe (negative X, minimal Y)
            if (swipeDistanceX < -swipeThreshold && swipeDistanceY < 100) {
              // Find and close the top-most visible overlay
              const taskModal = document.getElementById('task-modal-overlay');
              const breathingOverlay = document.getElementById('breathingOverlay');
              const countdownOverlay = document.getElementById('countdownOverlay');
              const completionOverlay = document.getElementById('completionOverlay');
              const triviaOverlay = document.getElementById('trivia-game-overlay');
              const movieOverlay = document.getElementById('movie-playback-overlay');
              
              if (taskModal && taskModal.classList.contains('visible')) {
                closeTaskModal();
                return;
              }
              
              if (triviaOverlay && triviaOverlay.classList.contains('visible')) {
                triviaOverlay.classList.remove('visible');
                return;
              }
              
              if (movieOverlay && movieOverlay.classList.contains('visible')) {
                movieOverlay.classList.remove('visible');
                return;
              }
              
              if (breathingOverlay && breathingOverlay.classList.contains('visible')) {
                breathingOverlay.classList.remove('visible');
                clearAllTimers();
                return;
              }
              
              if (countdownOverlay && countdownOverlay.classList.contains('visible')) {
                countdownOverlay.classList.remove('visible');
                clearAllTimers();
                return;
              }
              
              if (completionOverlay && completionOverlay.classList.contains('visible')) {
                completionOverlay.classList.remove('visible');
                return;
              }
            }
          }

          // Make panels draggable on iPad
          function makePanelDraggable(panel) {
            let isDragging = false;
            let currentX = 0;
            let currentY = 0;
            let initialX = 0;
            let initialY = 0;
            let xOffset = 0;
            let yOffset = 0;
            
            // Load saved position
            const savedPos = localStorage.getItem(`panel-position-${panel.id}`);
            if (savedPos) {
              const pos = JSON.parse(savedPos);
              xOffset = pos.x;
              yOffset = pos.y;
              panel.style.transform = `translate(${xOffset}px, ${yOffset}px)`;
            }
            
            const header = panel.querySelector('.panel-header');
            if (!header) return;
            
            header.style.cursor = 'move';
            header.style.touchAction = 'none';
            
            function dragStart(e) {
              if (e.type === 'touchstart') {
                initialX = e.touches[0].clientX - xOffset;
                initialY = e.touches[0].clientY - yOffset;
              } else {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
              }
              
              if (e.target === header || header.contains(e.target)) {
                isDragging = true;
              }
            }
            
            function drag(e) {
              if (!isDragging) return;
              
              e.preventDefault();
              
              if (e.type === 'touchmove') {
                currentX = e.touches[0].clientX - initialX;
                currentY = e.touches[0].clientY - initialY;
              } else {
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
              }
              
              // Constrain to viewport bounds
              const panelRect = panel.getBoundingClientRect();
              const maxX = window.innerWidth - panelRect.width;
              const maxY = window.innerHeight - panelRect.height;
              
              currentX = Math.max(0, Math.min(currentX, maxX));
              currentY = Math.max(0, Math.min(currentY, maxY));
              
              xOffset = currentX;
              yOffset = currentY;
              
              panel.style.transform = `translate(${currentX}px, ${currentY}px)`;
              panel.style.transition = 'none';
            }
            
            function dragEnd(e) {
              if (isDragging) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
                
                // Save position
                localStorage.setItem(`panel-position-${panel.id}`, JSON.stringify({
                  x: xOffset,
                  y: yOffset
                }));
                
                panel.style.transition = '';
              }
            }
            
            header.addEventListener('mousedown', dragStart);
            header.addEventListener('touchstart', dragStart, { passive: false });
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('touchend', dragEnd);
          }
          
          // Apply draggable to all panels
          document.querySelectorAll('.panel').forEach(panel => {
            makePanelDraggable(panel);
          });
        });
  </script>
</body>

</html>
